<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NewtonIO</title>
  <subtitle>技术、效率以及有的没的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://newton.sh/"/>
  <updated>2017-08-07T10:09:16.000Z</updated>
  <id>http://newton.sh/</id>
  
  <author>
    <name>Newton</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keyboard Maestro 一键即达的效率神奇</title>
    <link href="http://newton.sh/2017/08/05/keyboard-maestro/"/>
    <id>http://newton.sh/2017/08/05/keyboard-maestro/</id>
    <published>2017-08-05T06:35:24.000Z</published>
    <updated>2017-08-07T10:09:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Keyboard-Maestro"><a href="#Keyboard-Maestro" class="headerlink" title="Keyboard Maestro"></a>Keyboard Maestro</h1><p><a href="https://www.keyboardmaestro.com/main/" target="_blank" rel="external">Keyboard Maestro</a> 是一款 macOS 平台类似 Alfred 的效率神器，其核心思想也是以一个触发器（Trigger）操作触发一连串组合动作（Action）来高效便捷的完成复杂任务，同时也十分符合『一个程序只实现一个功能，组合小程序完成复杂任务』的 Linux 哲学。<br>关于 Keyboard Maestro（以下简称 KB） 本身的介绍和基本使用可以拜读少数派的<a href="https://sspai.com/post/36442" target="_blank" rel="external">这篇长文</a>，很详细覆盖也很全面，本篇主要记录分享下我个人使用中的一些用例和场景。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>只要我们的任务可以被<strong>分解为多个目的单一的小步骤，步骤与步骤之间可以通过标准输入输出传递数据串起来</strong>，这个任务就很可能可以使用 KB 来简化操作。</p>
<p><img src="media/tech-0-1.png" alt="tech-0"></p>
<p>在 KB 里作为触发器的就是一组快捷键，为了解决 macOS 上可用的快捷键总是捉襟见肘的情况，可以参考上一篇<a href="http://newton.sh/2017/06/24/karabiner-elements/">《Karabiner Elements 键位定制神器》</a>先配置一下 <code>Hyper Key</code>，可以尽可能的避免快捷键冲突问题。</p>
<h2 id="快捷键启动（切换）任意应用"><a href="#快捷键启动（切换）任意应用" class="headerlink" title="快捷键启动（切换）任意应用"></a>快捷键启动（切换）任意应用</h2><p>快捷键直接启动指定应用程序，这应该是最简单直接的应用场景，系统默认的 <code>Cmd + Tab</code> 显然总是无法 Get 到我到底想要切换哪个 App…最直接的方式就是给要切换的 App 钦定一个快捷键，无论在什么窗口下直接按下指定的快捷键就能马上脉动回来。<br>工作里我切换频率最高的 App 差不多是 Sublime、iTerm2、微信、QQ、Sequel Pro、AirMail、Chrome 和 Firefox。<br>以 Sublime 为例，我设置的快捷键为 <code>Ctrl + Alt + Shift + Cmd + s</code>，其中 <code>Ctrl + Alt + Shift + Cmd</code> 是 <code>Hyper Key</code>，实际操作只需要按下 <code>CapsLock + s</code>：</p>
<p><img src="media/15020295730202-1.jpg" alt="15020295730202"></p>
<h2 id="快捷键映射组合键"><a href="#快捷键映射组合键" class="headerlink" title="快捷键映射组合键"></a>快捷键映射组合键</h2><h2 id="快捷键执行-Shell-Apple-Script"><a href="#快捷键执行-Shell-Apple-Script" class="headerlink" title="快捷键执行 Shell/Apple Script"></a>快捷键执行 Shell/Apple Script</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Keyboard-Maestro&quot;&gt;&lt;a href=&quot;#Keyboard-Maestro&quot; class=&quot;headerlink&quot; title=&quot;Keyboard Maestro&quot;&gt;&lt;/a&gt;Keyboard Maestro&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
    
    </summary>
    
    
      <category term="Mac" scheme="http://newton.sh/tags/Mac/"/>
    
      <category term="Keyboard Maestro" scheme="http://newton.sh/tags/Keyboard-Maestro/"/>
    
  </entry>
  
  <entry>
    <title>Karabiner Elements 键位定制神器</title>
    <link href="http://newton.sh/2017/06/24/karabiner-elements/"/>
    <id>http://newton.sh/2017/06/24/karabiner-elements/</id>
    <published>2017-06-24T06:08:35.000Z</published>
    <updated>2017-08-07T10:05:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Karabiner"><a href="#Karabiner" class="headerlink" title="Karabiner"></a>Karabiner</h1><p><a href="https://pqrs.org/osx/karabiner" target="_blank" rel="external">Karabiner</a> 是一款 Mac 平台修改键位映射的软件，有任何需要更改键位默认行为的需求都可以尝试用 Karabiner 做相应的映射，开源且免费。</p>
<h1 id="Karabiner-Elements"><a href="#Karabiner-Elements" class="headerlink" title="Karabiner Elements"></a>Karabiner Elements</h1><p>在 macOS 更新到 Sierra 版本后原来的 Karabiner 版本失效了，于是作者起了一个新的项目 <a href="https://github.com/tekezo/Karabiner-Elements" target="_blank" rel="external">Karabiner Elements</a>，简易的实现了原版本的核心功能，让 macOS Sierra 以上的用户在原 Karabiner 新版开发完成之前先凑合用上。</p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><ul>
<li>普通键位映射：将键盘上的某个键位映射为任意指定的其他键位。</li>
<li>功能键位映射：将键盘上的功能键（Fn）映射为任意指定的其他键位。</li>
<li>可以同时对连接到 Mac 的多个键盘设备生效。</li>
<li>可以选择仅对特定键盘设备生效。</li>
<li>支持虚拟键盘（ANSI, ISO, JIS）等。</li>
<li>支持多套偏好设置，可根据场景切换使用。</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>除了官方 Github 上提供的版本外，建议安装 <a href="https://github.com/tekezo/Karabiner-Elements/pull/247" target="_blank" rel="external">这个 PR</a> 里的分支版本，提供了多个键位映射到一个键位的功能，目前还没有被合并到官方主分支。</p>
<p>下载：<a href="https://github.com/wwwjfy/Karabiner-Elements/releases" target="_blank" rel="external">https://github.com/wwwjfy/Karabiner-Elements/releases</a></p>
<p>安装完成后打开 Karabiner Elements，主界面如下：</p>
<img src="/2017/06/24/karabiner-elements/14982967543253.jpg" alt="14982967543253.jpg" title="">
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="键位映射"><a href="#键位映射" class="headerlink" title="键位映射"></a>键位映射</h2><p>在 Mac 上使用外接键盘一般都会遇到部分键位和 Mac 键盘布局不匹配的问题，系统本身提供了对于功能键的映射功能，但如果你的键盘有 <code>App</code>、<code>Fn</code> 等特殊按键，系统自带的配置功能就搞不定了。</p>
<img src="/2017/06/24/karabiner-elements/14982946693811.jpg" alt="14982946693811.jpg" title="">
<p>而在 Karabiner 里提供的选择非常多，基本可以覆盖绝大多数外接键盘可能用的键位。</p>
<img src="/2017/06/24/karabiner-elements/14982967198860.jpg" alt="14982967198860.jpg" title="">
<p>简单配置 <code>From Key</code> 和 <code>To Key</code> 即可完成一条键位映射的配置：</p>
<img src="/2017/06/24/karabiner-elements/14982970600598.jpg" alt="14982970600598.jpg" title="">
<p>比如上图就是把 <code>App</code> 键映射到 <code>右 Command</code> 键。</p>
<div class="tip"><br>需要注意的是 Karabiner 的配置会覆盖 macOS 自身的键盘配置，如果之前用默认的设置修改过修饰键等映射，使用 Karabiner 后都需要在 Karabiner 里配置一套相同的设置。<br></div>

<h2 id="多套配置"><a href="#多套配置" class="headerlink" title="多套配置"></a>多套配置</h2><p>在界面上的 <code>Profiles</code> 标签内，可以添加、删除和选中某个配置，<code>select</code> 选中某个配置之后，所有对键位的更改都会保存在当前 <code>select</code> 的这套配置内，比如可以根据使用的键盘不同维护多套配置，以便在使用不同输入设备时切换。</p>
<p>另外，Karabiner 的所有配置都以 <code>JSON</code> 格式文件保存在：</p>
<blockquote>
<p>~/.config/karabiner/karabiner.json</p>
</blockquote>
<p>目录，如果在网上看到别人给出的配置需要编辑 <code>karabiner.json</code> 文件加到其中，如果需要备份配置则可以直接备份这个目录。</p>
<div class="tip"><br>Karabiner Elements 目前<strong>并不支持一个键位映射只对某一个键盘设备生效</strong>，所以使用不同的键盘设备需要手动切换配置来启用。<br>这里有 <a href="https://github.com/tekezo/Karabiner-Elements/pull/752" target="_blank" rel="external">一个 PR</a> 提供了单个映射只对指定设备生效的支持，目前还没有被合并到 master，可以关注一下。<br></div>

<h2 id="Hyper-Key"><a href="#Hyper-Key" class="headerlink" title="Hyper Key"></a>Hyper Key</h2><p>所谓的 <strong>Hyper Key</strong> 就是将 <code>左 Control</code> + <code>左 Option</code> + <code>左 Command</code> + <code>左 Shift</code> 这四个键的组合键映射到某一个键上，一般映射到对大多数人都不太常用的 <code>CapsLock</code>（大小写锁定键）上，按下 <code>CapsLock</code> 键就相当于按下了以上 4 个键的组合键，这样一来可以使用 <strong><code>CapsLock</code> + 任意键</strong> 组合出一整套新的快捷键，而且几乎不会和所有第三方 App 或系统快捷键冲突，可以说是拯救了 Mac 上十分不够用的快捷键配置。</p>
<p>如果安装了上述<a href="https://github.com/wwwjfy/Karabiner-Elements/releases" target="_blank" rel="external">非官方分支的版本</a>，可以按以下步骤来设置 <code>Hyper Key</code>：</p>
<ol>
<li>用任意文本编辑器打开 <code>~/.config/karabiner/</code> 文件。</li>
<li>将下面的代码复制粘贴到红框中的位置。</li>
<li>保存文件。</li>
</ol>
<p>代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">"one_to_many_mappings": &#123;</div><div class="line">      "caps_lock": [</div><div class="line">          "left_control",</div><div class="line">          "left_shift",</div><div class="line">          "left_option",</div><div class="line">          "left_command"</div><div class="line">      ]</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>复制到下图红框中的位置：</p>
<img src="/2017/06/24/karabiner-elements/14983003863869.jpg" alt="14983003863869.jpg" title="">
<p>这段配置即可把 <code>左 Control</code> + <code>左 Shift</code> + <code>左 Option</code> + <code>左 Command</code> 映射到 <code>CapsLock</code> 键上。</p>
<p>可以看到 Karabiner 所有的配置描述都并列的写在了 <code>profiles</code> 这个 key 里面。</p>
<div class="tip"><br>添加配置描述的时候需要看清楚当前添加的是哪套配置文件，比如上面例子里添加的配置就属于 <code>PCKeyboard</code> 这套配置文件。<br></div>

<p>有了 <code>HyperKey</code> 再配合上 Keyboard Maestro 这样的工作流效率工具，基本上就是图形界面版的 AHK（AutoHotKey）。</p>
<h2 id="Alfred-Workflow"><a href="#Alfred-Workflow" class="headerlink" title="Alfred Workflow"></a>Alfred Workflow</h2><p>很多时候都可能需要维护不止一套配置，比如在办公室或家里会用外接键盘，带着笔记本出门一般只会用 Mac 自带的键盘，而 Karabiner 默认是通过点击菜单栏图标来切换配置：</p>
<img src="/2017/06/24/karabiner-elements/14983014591849.jpg" alt="14983014591849.jpg" title="">
<p>不仅需要鼠标精确操作而且常驻一个除此之外并没有太多卵用的菜单栏图标，这里提供一个快速切换配置的 AlfredWorkflow：</p>
<p><a href="https://github.com/Newt0n/newt0n.github.io/raw/master/2017/06/24/karabiner-elements/Karabiner%20Elements%20Profile.alfredworkflow" target="_blank" rel="external">https://github.com/Newt0n/newt0n.github.io/raw/master/2017/06/24/karabiner-elements/Karabiner%20Elements%20Profile.alfredworkflow</a></p>
<p>默认关键词 <code>kep</code>，选择配置名称完成切换，全键盘操作：</p>
<img src="/2017/06/24/karabiner-elements/14983016279993.jpg" alt="14983016279993.jpg" title="">
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Karabiner-EventViewer"><a href="#Karabiner-EventViewer" class="headerlink" title="Karabiner EventViewer"></a>Karabiner EventViewer</h2><p>Karabiner 提供了查看每个键位代码名称的工具 <code>Karabiner-EventViewer</code>，打开该工具，随后的所有按键操作都会在界面上显示明细，如果有不清楚名称的按键，查看界面中 <code>name</code> 一栏，配置映射时选择对应名称的键位即可。</p>
<img src="/2017/06/24/karabiner-elements/14983023161858.jpg" alt="14983023161858.jpg" title="">
<p>对我而言 Karabiner 最主要的用途就是用配置的 <code>HyperKey</code> 配合 Keyboard Maestro 来实现各种定制化快捷操作，相比以前在 Win 上用 AHK，给我的感觉是功能和灵活性不输，图形界面则更佳方便易用，有空会再分享一篇 Keyboard Maestro 的使用场景。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/tekezo/Karabiner-Elements/" target="_blank" rel="external">https://github.com/tekezo/Karabiner-Elements/</a></li>
<li><a href="https://github.com/wwwjfy/Karabiner-Elements/" target="_blank" rel="external">https://github.com/wwwjfy/Karabiner-Elements/</a></li>
<li><a href="https://github.com/tekezo/Karabiner-Elements/pull/752" target="_blank" rel="external">https://github.com/tekezo/Karabiner-Elements/pull/752</a></li>
<li><a href="https://github.com/tekezo/Karabiner-Elements/pull/247" target="_blank" rel="external">https://github.com/tekezo/Karabiner-Elements/pull/247</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Karabiner&quot;&gt;&lt;a href=&quot;#Karabiner&quot; class=&quot;headerlink&quot; title=&quot;Karabiner&quot;&gt;&lt;/a&gt;Karabiner&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pqrs.org/osx/karabiner&quot; t
    
    </summary>
    
    
      <category term="Mac" scheme="http://newton.sh/tags/Mac/"/>
    
      <category term="Karabiner" scheme="http://newton.sh/tags/Karabiner/"/>
    
  </entry>
  
  <entry>
    <title>Sequel Pro 如何实现更好的 SQL 格式化</title>
    <link href="http://newton.sh/2017/04/14/Sequel-Pro-SQL-Formatter/"/>
    <id>http://newton.sh/2017/04/14/Sequel-Pro-SQL-Formatter/</id>
    <published>2017-04-14T10:19:06.000Z</published>
    <updated>2017-05-09T05:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>让 Mac 上的数据库管理客户端 Sequel Pro 有更好的 SQL 格式化功能。<br><a id="more"></a></p>
<p>说起 Mac 上的数据库管理 App，靠谱的可选项并不多，除了 Win 平台同样有的老牌全功能客户端 Navicat，仅有 Sequel Pro、SQLPro Studio 等几个轻量的选择以及官方的 Workbench 和发布不久的 DataGrip。</p>
<p>在工具的选择上一向偏爱简洁够用就好，最初用 Mac 时反复比较了多个可选项最终选择了开源的 Sequel Pro 作为首选客户端，和之前在 Win 上主要用的 SQLyog 相比，界面操作之类的都可以习惯，唯独 SQL 格式化功能始终不能忍受。</p>
<h2 id="自带格式化功能入口"><a href="#自带格式化功能入口" class="headerlink" title="自带格式化功能入口"></a>自带格式化功能入口</h2><p>Sequel Pro 的 SQL 格式化功能以 Bundle 也就是插件的形式提供，使用菜单 <code>Bundles-&gt;Input Field-&gt;Format-&gt;Format SQL</code> 执行。</p>
<img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14925125535553.jpg" alt="14925125535553.jpg" title="">
<h2 id="修正自带-Bundle"><a href="#修正自带-Bundle" class="headerlink" title="修正自带 Bundle"></a>修正自带 Bundle</h2><p>官方版本自带的 Bundle 很可能无法开箱即用：</p>
<img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14925128749849.png" alt="14925128749849.png" title="">
<p>可以根据这个 Issue (<a href="https://github.com/sequelpro/sequelpro/issues/1988#issuecomment-60658598" target="_blank" rel="external">https://github.com/sequelpro/sequelpro/issues/1988#issuecomment-60658598</a>) 下的评论修正：</p>
<ul>
<li>打开菜单 <code>Bundles -&gt; Bundle Editor</code></li>
<li>左边栏选择 <code>Input field</code> (Show) -&gt; <code>Format</code> (Show) -&gt; <code>Format SQL</code> (Show)</li>
<li>在 “Command” 区域找到这行代码 <code>&lt;input type=&quot;hidden&quot; name=&quot;clientid&quot; value=&quot;...&quot; /&gt;</code></li>
<li>把这个 <code>input</code> 的 <code>value</code> 改为 <code>dpriver-9094-8133-2031</code></li>
<li>保存</li>
</ul>
<p>这样修改后 SQL 格式化应该可以正常工作。</p>
<div class="tip"><br>可以发现 Sequel Pro 提供的 SQL 格式化功能是以调用远程接口服务来实现的，并不是客户端内置的原生功能，使用时也需要联网。<br></div>

<h2 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h2><p>自带的 Bundle 修正之后基本功能没问题，但执行的时候不仅会弹出个调用远程接口的对话框，而且 SQL 的格式也不太令人满意。</p>
<p>除了 Sequel Pro 提供的 Bundle 所使用的 SQL格式化的服务外，还有其他类似的服务同样提供了可随意调用的 API，比如 <a href="https://sqlformat.org/" target="_blank" rel="external">sqlformat.org</a>。</p>
<p>这里就以 <a href="https://sqlformat.org/" target="_blank" rel="external">sqlformat.org</a> 为例介绍一下如何创建一个比官方更好用的自定义 SQL 格式化 Bundle。</p>
<h3 id="打开-Bundle-编辑器"><a href="#打开-Bundle-编辑器" class="headerlink" title="打开 Bundle 编辑器"></a>打开 Bundle 编辑器</h3><p>按菜单 <code>Bundles</code> -&gt; <code>Bundle Editor</code> 打开编辑器</p>
<img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14926890939691.jpg" alt="14926890939691.jpg" title="">
<h3 id="创建-Bundle"><a href="#创建-Bundle" class="headerlink" title="创建 Bundle"></a>创建 Bundle</h3><p>将侧边菜单展开到 <code>Input Field</code> -&gt; <code>Format</code> -&gt; <code>Format SQL</code>，右键创建一个副本。</p>
<img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14926892176026.jpg" alt="14926892176026.jpg" title="">
<h3 id="配置-Bundle"><a href="#配置-Bundle" class="headerlink" title="配置 Bundle"></a>配置 Bundle</h3><img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14926894425970.jpg" alt="14926894425970.jpg" title="">
<p>注意将 <code>OutPut</code> 项更改为 <code>Replace Selection</code>(这样调用远程接口时就不会弹窗)，然后在 <code>Command</code> 部分贴入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> urllib2, urllib</div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line">sql = sys.stdin.read()</div><div class="line">params = &#123;<span class="string">'sql'</span>: sql, <span class="string">'reindent'</span>: <span class="number">1</span>, <span class="string">'keyword_case'</span>: <span class="string">'upper'</span>, <span class="string">'identifier_case'</span>: <span class="string">'lower'</span>&#125;</div><div class="line">response = urllib2.urlopen(<span class="string">'https://sqlformat.org/api/v1/format'</span>, data=urllib.urlencode(params))</div><div class="line">data = json.loads(response.read())</div><div class="line"><span class="keyword">print</span> data[<span class="string">'result'</span>]</div></pre></td></tr></table></figure>
<p>代码的功能就是调用了 <a href="https://sqlformat.org/" target="_blank" rel="external">sqlformat.org</a> 的 API 并用格式化后的结果替换掉所选择的 SQL，代码贴完后 <code>Save</code>，从菜单里启用或者设置个快捷键看看效果吧。</p>
<p>这样一条 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">TYPE</span>, <span class="keyword">sum</span>(<span class="keyword">CASE</span> vender <span class="keyword">WHEN</span> <span class="string">'A'</span> <span class="keyword">THEN</span> pcs <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>), <span class="keyword">sum</span>(<span class="keyword">CASE</span> vender <span class="keyword">WHEN</span> <span class="string">'C'</span> <span class="keyword">THEN</span> pcs <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>), <span class="keyword">sum</span>(<span class="keyword">CASE</span> vender <span class="keyword">WHEN</span> <span class="string">'B'</span> <span class="keyword">THEN</span> pcs <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">FROM</span> tablename t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t1 <span class="keyword">ON</span> t1.id = t.id <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t2.id = t.id <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`type`</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> t.create_time <span class="keyword">DESC</span> <span class="keyword">HAVING</span> t.cnt &gt; <span class="number">2</span></div></pre></td></tr></table></figure>
<p>格式化之后：</p>
<img src="/2017/04/14/Sequel-Pro-SQL-Formatter/14926907232365.jpg" alt="14926907232365.jpg" title="">
<p><a href="https://sqlformat.org/" target="_blank" rel="external">sqlformat.org</a> 的 API 文档里还有一些可选项可以设置，比如是否大写关键字、缩进宽度、是否移除注释等，可以参考文档修改代码参数。</p>
<ul>
<li><a href="https://sqlformat.org/api/" target="_blank" rel="external">https://sqlformat.org/api/</a></li>
</ul>
<p>附 PHP 版代码，效果一致：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/php</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$sql = @file_get_contents(<span class="string">"php://stdin"</span>);</div><div class="line"></div><div class="line">$req = [</div><div class="line">	<span class="string">'reindent'</span> =&gt; <span class="number">1</span>,</div><div class="line">	<span class="string">'sql'</span> =&gt; $sql,</div><div class="line">	<span class="string">'keyword_case'</span> =&gt; <span class="string">'upper'</span>,</div><div class="line">	<span class="string">'identifier_case'</span> =&gt; <span class="string">'lower'</span>,</div><div class="line">];</div><div class="line"></div><div class="line">$ch = curl_init();</div><div class="line">curl_setopt($ch, CURLOPT_URL, <span class="string">'https://sqlformat.org/api/v1/format'</span>);</div><div class="line">curl_setopt($ch, CURLOPT_POST, count($req));</div><div class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($req));</div><div class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="keyword">true</span>);</div><div class="line">$ret = curl_exec($ch);</div><div class="line">curl_close($ch);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> json_decode($ret, <span class="keyword">true</span>)[<span class="string">'result'</span>];</div></pre></td></tr></table></figure>
<p>懒得折腾，下载打包好的 Bundle 直接导入即可：</p>
<blockquote>
<p><a href="http://newt0n.github.io/2017/04/14/Sequel-Pro-SQL-Formatter/Format-SQL-Py.spBundle.zip" target="_blank" rel="external">http://newt0n.github.io/2017/04/14/Sequel-Pro-SQL-Formatter/Format-SQL-Py.spBundle.zip</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/sequelpro/sequelpro/issues/1988#issuecomment-60658598" target="_blank" rel="external">Update SQL formatter bundle for new API</a></li>
<li><a href="https://sqlformat.org/" target="_blank" rel="external">SQLFormat</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让 Mac 上的数据库管理客户端 Sequel Pro 有更好的 SQL 格式化功能。&lt;br&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://newton.sh/tags/SQL/"/>
    
      <category term="Mac" scheme="http://newton.sh/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Go Range 内部实现</title>
    <link href="http://newton.sh/2017/04/06/Go-Range-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://newton.sh/2017/04/06/Go-Range-内部实现/</id>
    <published>2017-04-06T11:19:57.000Z</published>
    <updated>2017-04-10T16:23:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 里的 <code>for...range</code> 循环用起来非常方便，本篇讨论了多种不同情况下这一用法的表现及内部原理。<br><a id="more"></a></p>
<blockquote>
<p>原文：<a href="https://garbagecollected.org/2017/02/22/go-range-loop-internals/" target="_blank" rel="external">Go Range Loop Internals</a></p>
</blockquote>
<p>Go 里的 <code>range</code> 循环用起来非常方便，但我总觉得它在不同情况下的表现有点神秘。现在看来我并不孤单：</p>
<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/golang?src=hash" target="_blank" rel="external">#golang</a> pop quiz: does this program terminate?<br><br>func main() {<br>   v := []int{1, 2, 3}<br>   for i := range v {<br>       v = append(v, i)<br>  }<br>}</p>&mdash; Dαve Cheney (@davecheney) <a href="https://twitter.com/davecheney/status/819759166617108481" target="_blank" rel="external">January 13, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Today&#39;s <a href="https://twitter.com/hashtag/golang?src=hash" target="_blank" rel="external">#golang</a> gotcha: the two-value range over an array does a copy.  Avoid by ranging over the pointer instead.<a href="https://t.co/SbK667osvA" target="_blank" rel="external">https://t.co/SbK667osvA</a></p>&mdash; Damian Gryski (@dgryski) <a href="https://twitter.com/dgryski/status/816226596835225600" target="_blank" rel="external">January 3, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>在亲自测试了两位大神的例子后，现在我应该接受并记住这些事实，但死记硬背的东西总是容易忘。搞清楚背后的原理是什么，才更有利于加深理解和记忆，让我们开始吧。</p>
<h2 id="第一步：读读该死的手册（Read-The-Fxxking-Manual）"><a href="#第一步：读读该死的手册（Read-The-Fxxking-Manual）" class="headerlink" title="第一步：读读该死的手册（Read The Fxxking Manual）"></a>第一步：读读该死的手册（Read The Fxxking Manual）</h2><p>先来读一下关于 <code>range</code> 的文档。在 Go 规范文档 “For statements with range clause” 一节可以找到关于 <code>for...range</code> 语法相关的说明。我不会把整个文档都拷贝过来，但会汇总一些有对我们有用的部分。</p>
<p>首先，提醒一下自己我们要重点注意的是什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</div><div class="line">    fmt.Println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="range-变量"><a href="#range-变量" class="headerlink" title="range 变量"></a>range 变量</h3><p>我们应该都知道，对于 range 左边的循环变量（上面这个例子里的 <code>i</code>）可以用以下方式来赋值：</p>
<ul>
<li>等号直接赋值 (<code>=</code>)</li>
<li>短变量申明赋值 (<code>:=</code>)</li>
</ul>
<p>当然也可以什么都不写来完全忽略迭代遍历到的值。</p>
<p>如果使用短变量申明（<code>:=</code>），Go 会在每次循环的迭代中重用申明的变量（只在循环内的作用域里有效）</p>
<h3 id="range-表达式"><a href="#range-表达式" class="headerlink" title="range 表达式"></a>range 表达式</h3><p><code>range</code> 右边（上述例子里的 <code>a</code>）表达式的结果，可以是以下这些数据类型：</p>
<ul>
<li>数组</li>
<li>指向数组的指针</li>
<li>切片</li>
<li>字符串</li>
<li>map</li>
<li>可以接收传输的 <code>channel</code>, 比如：<code>chan int or chan&lt;- int</code></li>
</ul>
<p><strong>range 表达式会在开始循环前被 evaluated 一次</strong>。但有一个例外情况：</p>
<div class="tip"><br>如果对一个数组或者指向数组的指针做 <code>range</code> 并且只用到了数组索引：此时只有 <code>len(a)</code> 被 <strong>evaluated</strong>。<br></div>

<p>仅仅只 evaluating <code>len(a)</code> 意味着表达式 <code>a</code> 可能在编译时被 evaluated 然后被编译器替换成了常量。规范文档里对 <code>len</code> 的解释：</p>
<blockquote>
<p>如果变量 <code>s</code> 是数组、指向数组的指针并且表达式里没有可以接收输入的 channel 或者函数调用（非常量），这些情况下 <code>s</code> 不会被 <strong>evaluated</strong>，<code>len(s)</code> 和 <code>cap(s)</code> 都是常量；除此之外 <code>len</code> 和 <code>cap</code> 的调用都不是常量并且 <code>s</code> 会被 <strong>evaluated</strong>。</p>
</blockquote>
<p>所以<strong>这里的 <code>evaluated</code> 到底是什么意思</strong>？很不幸文档里没有找到相关的说明。当然我猜其实就是完全的执行表达式直到其不能再被拆解。无论如何，最重要的是 <code>range</code> 表达式 在整个迭代开始前会被完全的执行一次。<strong>那么你会怎么让一个表达式只执行一次？把执行结果放在一个变量里！</strong> <code>range</code> 表达式的处理会不会也是这么做的？</p>
<p>有趣的是规范文档里提到了一些对 <code>maps</code> (没有提到 <code>slices</code>) 做添加或删除操作的情况。</p>
<p>如果 <code>map</code> 中的元素在还没有被遍历到时就被移除了，后续的迭代中这个元素就不会再出现。而如果 <code>map</code> 中的元素是在迭代过程中被添加的，那么在后续的迭代这个元素可能出现也可能被跳过。</p>
<p>稍等一会我们再回来聊 <code>maps</code>。</p>
<h2 id="第二步-range-支持的数据类型"><a href="#第二步-range-支持的数据类型" class="headerlink" title="第二步: range 支持的数据类型"></a>第二步: range 支持的数据类型</h2><p>如果我们假设在循环开始之前会先把 <code>range</code> 表达式复制给一个变量，那我们需要关注什么？答案是表达式结果的数据类型，让我们更近一步的看看 <code>range</code> 支持的数据类型。</p>
<p>在我们开始前，先记住：在 Go 里，无论我们对什么赋值，都会被复制。如果赋值了一个指针，那我们就复制了一个指针副本。如果赋值了一个结构体，那我们就复制了一个结构体副本。往函数里传参也是同样的情况。好了，开始吧：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">谁的语法糖？</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">数组</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">一个结构体：拥有一个变量 <code>len</code> 和一个指针指向背后的数组</td>
</tr>
<tr>
<td style="text-align:center">slice</td>
<td style="text-align:center">一个结构体：拥有一个变量 <code>len</code> 、一个变量 <code>cap</code> 和一个指针指向背后的数组</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">指向一个结构体的指针</td>
</tr>
<tr>
<td style="text-align:center">channel</td>
<td style="text-align:center">指向一个结构体的指针</td>
</tr>
</tbody>
</table>
<p>本文的末尾列出了一些参考，可以进一步了解这些数据类型的内部结构。</p>
<p>所以这些到底有什么 luǎn 用？下面的例子着重标记出了一些不同点：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 复制整个数组</span></div><div class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line">acopy := a </div><div class="line"></div><div class="line"><span class="comment">// 只复制了 slice 的结构体，并没有复制成员指针指向的数组</span></div><div class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</div><div class="line">scopy := s</div><div class="line"></div><div class="line"><span class="comment">// 只复制了 map 的指针</span></div><div class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">mcopy := m</div></pre></td></tr></table></figure>
<p>所以，如果要在 range 循环开始前把一个数组表达式赋值给一个变量（保证表达式只 evaluate 一次），就会复制整个数组。</p>
<h2 id="第三步-Go-编译器源码"><a href="#第三步-Go-编译器源码" class="headerlink" title="第三步: Go 编译器源码"></a>第三步: Go 编译器源码</h2><p>偷懒如我直接 google 了一下 Go 的编译器源码。首先发现的是 GCC 版本的编译器。我们关心的和 range 有关的部分出现在 <code>statements.cc</code>，<a href="https://github.com/golang/gofrontend/blob/e387439bfd24d5e142874b8e68e7039f74c744d7/go/statements.cc#L5384" target="_blank" rel="external">就像注释里写的</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Arrange to do a loop appropriate for the type.  We will produce</span></div><div class="line"><span class="comment">//   for INIT ; COND ; POST &#123;</span></div><div class="line"><span class="comment">//           ITER_INIT</span></div><div class="line"><span class="comment">//           INDEX = INDEX_TEMP</span></div><div class="line"><span class="comment">//           VALUE = VALUE_TEMP // If there is a value</span></div><div class="line"><span class="comment">//           original statements</span></div><div class="line"><span class="comment">//   &#125;</span></div></pre></td></tr></table></figure>
<p>现在终于有点眉目了。<code>range</code> 循环在内部实现上实际就是 C 风格循环的语法糖，意料之外而又在情理之中。编译器会对每一种 <code>range</code> 支持的类型做专门的 “<strong>语法糖还原</strong>”。比如，</p>
<p><a href="https://github.com/golang/gofrontend/blob/e387439bfd24d5e142874b8e68e7039f74c744d7/go/statements.cc#L5501" target="_blank" rel="external">数组</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The loop we generate:</span></div><div class="line"><span class="comment">//   len_temp := len(range)</span></div><div class="line"><span class="comment">//   range_temp := range</span></div><div class="line"><span class="comment">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span></div><div class="line"><span class="comment">//           value_temp = range_temp[index_temp]</span></div><div class="line"><span class="comment">//           index = index_temp</span></div><div class="line"><span class="comment">//           value = value_temp</span></div><div class="line"><span class="comment">//           original body</span></div><div class="line"><span class="comment">//   &#125;</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/golang/gofrontend/blob/e387439bfd24d5e142874b8e68e7039f74c744d7/go/statements.cc#L5593" target="_blank" rel="external">切片</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//   for_temp := range</span></div><div class="line"><span class="comment">//   len_temp := len(for_temp)</span></div><div class="line"><span class="comment">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span></div><div class="line"><span class="comment">//           value_temp = for_temp[index_temp]</span></div><div class="line"><span class="comment">//           index = index_temp</span></div><div class="line"><span class="comment">//           value = value_temp</span></div><div class="line"><span class="comment">//           original body</span></div><div class="line"><span class="comment">//   &#125;</span></div></pre></td></tr></table></figure>
<p>他们的共同点是：</p>
<ul>
<li>所有类型的 <code>range</code> 本质上都是 C 风格的循环</li>
<li>遍历到的值会被赋值给一个临时变量</li>
</ul>
<p>这是 <a href="https://github.com/golang/gofrontend" target="_blank" rel="external">gofrontend</a>里的情况，据我所知大多数人使用的是 Go 发行版自带的 gc 编译器，看上去他们在这一点的处理上有着<a href="https://github.com/golang/go/blob/ea020ff3de9482726ce7019ac43c1d301ce5e3de/src/cmd/compile/internal/gc/range.go#L169" target="_blank" rel="external">完全相同的行为</a>。</p>
<h2 id="我们所知道的"><a href="#我们所知道的" class="headerlink" title="我们所知道的"></a>我们所知道的</h2><ol>
<li>循环变量在每一次迭代中都被赋值并会复用。</li>
<li>可以在迭代过程中移除一个 map 里的元素或者向 map 里添加元素。添加的元素并不一定会在后续迭代中被遍历到。</li>
<li>明确了这些之后，我们再回到开篇列出的例子上。</li>
</ol>
<h2 id="Dave-的推文"><a href="#Dave-的推文" class="headerlink" title="Dave 的推文"></a>Dave 的推文</h2><p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/golang?src=hash" target="_blank" rel="external">#golang</a> pop quiz: does this program terminate?<br><br>func main() {<br>   v := []int{1, 2, 3}<br>   for i := range v {<br>       v = append(v, i)<br>  }<br>}</p>&mdash; Dαve Cheney (@davecheney) <a href="https://twitter.com/davecheney/status/819759166617108481" target="_blank" rel="external">January 13, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>这段代码之所以会终止是因为它其实可以粗略的翻译成类似下面的这段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for_temp := v</div><div class="line">len_temp := <span class="built_in">len</span>(for_temp)</div><div class="line"><span class="keyword">for</span> index_temp = <span class="number">0</span>; index_temp &lt; len_temp; index_temp++ &#123;</div><div class="line">        value_temp = for_temp[index_temp]</div><div class="line">        index = index_temp</div><div class="line">        value = value_temp</div><div class="line">        v = <span class="built_in">append</span>(v, index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道切片实际上是一个结构体的语法糖，这个结构体有着一个指向数组的指针成员。在循环开始前对这个结构体生成副本然后赋值给 <code>for_temp</code>，后面的循环实际上是在对 <code>for_temp</code> 进行迭代。任何对于原始变量 <code>v</code> 本身（而非对其背后指向的数组）的更改都和生成的副本 <code>for_temp</code> 没有关系。但其背后指向的数组还是以指针的形式共享给 <code>v</code> 和 <code>for_temp</code>，所以 <code>v[i] = 1</code> 这样的语句仍然可以工作。</p>
<h2 id="Damian-的推文"><a href="#Damian-的推文" class="headerlink" title="Damian 的推文"></a>Damian 的推文</h2><p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Today&#39;s <a href="https://twitter.com/hashtag/golang?src=hash" target="_blank" rel="external">#golang</a> gotcha: the two-value range over an array does a copy.  Avoid by ranging over the pointer instead.<a href="https://t.co/SbK667osvA" target="_blank" rel="external">https://t.co/SbK667osvA</a></p>&mdash; Damian Gryski (@dgryski) <a href="https://twitter.com/dgryski/status/816226596835225600" target="_blank" rel="external">January 3, 2017</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>和上面的例子类似，在循环开始前数组被赋值给了一个临时变量，在对<strong>数组</strong>做 <code>range</code> 循环时临时变量里存放的是<strong>整个数组的副本</strong>，对原数组的操作不会反映在副本上。而在对<strong>数组指针</strong>做 <code>range</code> 循环时临时变量存放的是<strong>指针的副本</strong>，操作的也是同一块内存空间。</p>
<h2 id="附-maps"><a href="#附-maps" class="headerlink" title="附: maps"></a>附: maps</h2><p>在规范文档里我们读到：</p>
<ul>
<li>在 <code>range</code> 循环里对 <code>maps</code> 做添加或删除元素的操作是安全的。</li>
<li>如果在循环中对 <code>maps</code> 添加了一个元素，那么这个元素并不一定会出现在后续的迭代中。</li>
</ul>
<p><strong>对于第一点</strong>，我们知道 <code>maps</code> 实际上是结构体的指针。循环开始前，只会复制指针而不是内部的数据结构，因此在循环中添加或删除元素所操作的内存空间和原变量一致，合情合理。</p>
<p>那<strong>为什么在后续的迭代中不一定能遍历到当前添加的元素</strong>？如果你知道哈希表是如何工作的（map 本质上就是哈希表），就会明白哈希表内部数组里的元素并不是以特定顺序存放。最后一个添加的元素有可能经过哈希后被放到了内部数组里的第一个索引位，我们确实没有办法预测当前添加的元素是否会出现在后续的迭代中，毕竟在添加元素的时候很可能已经遍历过了第一个索引位。因此，当前添加的元素是否能在后续迭代中遍历到，还是看编译器的心情吧 :D</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://golang.org/ref/spec" target="_blank" rel="external">The Go Programming Language Specification</a></li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="external">Go slices: usage and internals</a></li>
<li><a href="https://research.swtch.com/godata" target="_blank" rel="external">Go Data Structures</a></li>
<li>Inside the map implementation: <a href="https://docs.google.com/presentation/d/1CxamWsvHReswNZc7N2HMV7WPFqS8pvlPVZcDegdC_T4/edit#slide=id.g153a5e64a5_1_0" target="_blank" rel="external">slides</a> | <a href="https://www.youtube.com/watch?v=Tl7mi9QmLns" target="_blank" rel="external">video</a></li>
<li>Understanding nil: <a href="https://speakerdeck.com/campoy/understanding-nilhttps://www.youtube.com/watch?v=ynoY2xz-F8s" target="_blank" rel="external">slides</a> | <a href="">video</a></li>
<li><a href="https://golang.org/src/runtime/string.go" target="_blank" rel="external">string source code</a></li>
<li><a href="https://golang.org/src/runtime/slice.go" target="_blank" rel="external">slice source code</a></li>
<li><a href="https://golang.org/src/runtime/hashmap.go" target="_blank" rel="external">map source code</a></li>
<li><a href="https://golang.org/src/runtime/chan.go" target="_blank" rel="external">channel source code</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 里的 &lt;code&gt;for...range&lt;/code&gt; 循环用起来非常方便，本篇讨论了多种不同情况下这一用法的表现及内部原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://newton.sh/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PHP 协程实现</title>
    <link href="http://newton.sh/2017/02/10/PHP-%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/"/>
    <id>http://newton.sh/2017/02/10/PHP-协程原理/</id>
    <published>2017-02-10T09:34:28.000Z</published>
    <updated>2017-04-25T14:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现 PHP 协程需要了解的基本内容。<br><a id="more"></a></p>
<h2 id="多进程-线程"><a href="#多进程-线程" class="headerlink" title="多进程/线程"></a>多进程/线程</h2><p>最早的服务器端程序都是通过多进程、多线程来解决并发IO的问题。进程模型出现的最早，从Unix 系统诞生就开始有了进程的概念。最早的服务器端程序一般都是 Accept 一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞地与客户端连接进行交互，收发处理数据。</p>
<p>多线程模式出现要晚一些，线程与进程相比更轻量，而且线程之间共享内存堆栈，所以不同的线程之间交互非常容易实现。比如实现一个聊天室，客户端连接之间可以交互，聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存等等统称进程间通信（IPC）复杂的技术才能实现。</p>
<p><strong>最简单的多进程服务端模型</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0:8000"</span>, $errno, $errstr) </div><div class="line"><span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Create server failed"</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">	$conn = stream_socket_accept($serv);</div><div class="line">	<span class="keyword">if</span> (pcntl_fork() == <span class="number">0</span>) &#123;</div><div class="line">		$request = fread($conn);</div><div class="line">		<span class="comment">// do something</span></div><div class="line">		<span class="comment">// $response = "hello world";</span></div><div class="line">		fwrite($response);</div><div class="line">		fclose($conn);</div><div class="line">		<span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多进程/线程模型的流程是：</p>
<p>创建一个 <code>socket</code>，绑定服务器端口（<code>bind</code>），监听端口（<code>listen</code>），在 PHP 中用 <code>stream_socket_server</code> 一个函数就能完成上面 3 个步骤，当然也可以使用更底层的<code>sockets</code> 扩展分别实现。</p>
<p>进入 <code>while</code> 循环，阻塞在 <code>accept</code> 操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起 <code>connect</code> 到服务器，操作系统会唤醒此进程。<code>accept</code> 函数返回客户端连接的 <code>socket</code> 主进程在多进程模型下通过 <code>fork</code>（php: pcntl_fork）创建子进程，多线程模型下使用 <code>pthread_create</code>（php: new Thread）创建子线程。</p>
<p>下文如无特殊声明将使用进程同时表示进程/线程。</p>
<p>子进程创建成功后进入 <code>while</code> 循环，阻塞在 <code>recv</code>（php:fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用 <code>send</code>（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会 <code>close</code>。</p>
<p>当客户端连接关闭时，子进程退出并销毁所有资源，主进程会回收掉此子进程。</p>
<img src="/2017/02/10/PHP-协程原理/14906085938366.jpg" alt="14906085938366.jpg" title="">
<p>这种模式最大的问题是，进程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的 <code>Leader-Follower</code> 模型。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0:8000"</span>, $errno, $errstr) </div><div class="line"><span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Create server failed"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">32</span>; $i++) &#123;</div><div class="line">    <span class="keyword">if</span> (pcntl_fork() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">            $conn = stream_socket_accept($serv);</div><div class="line">            <span class="keyword">if</span> ($conn == <span class="keyword">false</span>) <span class="keyword">continue</span>;</div><div class="line">            <span class="comment">// do something</span></div><div class="line">            $request = fread($conn);</div><div class="line">            <span class="comment">// $response = "hello world";</span></div><div class="line">            fwrite($response);</div><div class="line">            fclose($conn);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的特点是程序启动后就会创建 N 个进程。每个子进程进入 <code>Accept</code>，等待新的连接进入。当客户端连接到服务器时，其中一个子进程会被唤醒，开始处理客户端请求，并且不再接受新的 TCP 连接。当此连接关闭时，子进程会释放，重新进入 <code>Accept</code>，参与处理新的连接。</p>
<p>这个模型的优势是完全可以复用进程，没有额外消耗，性能非常好。很多常见的服务器程序都是基于此模型的，比如 Apache、PHP-FPM。</p>
<p>多进程模型也有一些缺点。</p>
<p>这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。</p>
<p>启动大量进程会带来额外的进程调度消耗。数百个进程时可能进程上下文切换调度消耗占 CPU 不到 1% 可以忽略不计，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到 CPU 的百分之几十甚至 100%。</p>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>谈到多进程以及类似同时执行多个任务的模型，就不得不先谈谈并行和并发。</p>
<h3 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h3><p>是指能处理多个同时活动的能力，并发事件之间不一定要同一时刻发生。</p>
<h3 id="并行（Parallesim）"><a href="#并行（Parallesim）" class="headerlink" title="并行（Parallesim）"></a>并行（Parallesim）</h3><p>是指同时刻发生的两个并发事件，具有并发的含义，但并发不一定并行。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>『并发』指的是程序的结构，『并行』指的是程序运行时的状态</li>
<li>『并行』一定是并发的，『并行』是『并发』设计的一种</li>
<li>单线程永远无法达到『并行』状态</li>
</ul>
<p>正确的并发设计的标准是：</p>
<blockquote>
<p>使多个操作可以在重叠的时间段内进行。<br>two tasks can start, run, and complete in overlapping time periods</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="http://www.vaikan.com/docs/Concurrency-is-not-Parallelism" target="_blank" rel="external">http://www.vaikan.com/docs/Concurrency-is-not-Parallelism</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="external">https://talks.golang.org/2012/waza.slide</a></li>
</ul>
<h2 id="迭代器-amp-生成器"><a href="#迭代器-amp-生成器" class="headerlink" title="迭代器 &amp; 生成器"></a>迭代器 &amp; 生成器</h2><p>在了解 PHP 协程前，还有 <strong>迭代器</strong> 和 <strong>生成器</strong> 这两个概念需要先认识一下。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>PHP5 开始内置了 <code>Iterator</code> 即迭代器接口，所以如果你定义了一个类，并实现了<code>Iterator</code> 接口，那么你的这个类对象就是 <code>ZEND_ITER_OBJECT</code> 即可迭代的，否则就是 <code>ZEND_ITER_PLAIN_OBJECT</code>。</p>
<p>对于 <code>ZEND_ITER_PLAIN_OBJECT</code> 的类，<code>foreach</code> 会获取该对象的默认属性数组，然后对该数组进行迭代。</p>
<p>而对于 <code>ZEND_ITER_OBJECT</code> 的类对象，则会通过调用对象实现的 <code>Iterator</code> 接口相关函数来进行迭代。</p>
<p>任何实现了 <code>Iterator</code> 接口的类都是<strong>可迭代的</strong>，即都可以用 <code>foreach</code> 语句来遍历。</p>
<h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> <span class="keyword">extends</span> <span class="title">Traversable</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 获取当前内部标量指向的元素的数据</span></div><div class="line">    <span class="keyword">public</span> mixed current()</div><div class="line"></div><div class="line">	<span class="comment">// 获取当前标量</span></div><div class="line">    <span class="keyword">public</span> scalar key()</div><div class="line"></div><div class="line">	<span class="comment">// 移动到下一个标量</span></div><div class="line">    <span class="keyword">public</span> void next()</div><div class="line"></div><div class="line">	<span class="comment">// 重置标量</span></div><div class="line">    <span class="keyword">public</span> void rewind()</div><div class="line"></div><div class="line">	<span class="comment">// 检查当前标量是否有效</span></div><div class="line">    <span class="keyword">public</span> boolean valid()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常规实现-range-函数"><a href="#常规实现-range-函数" class="headerlink" title="常规实现 range 函数"></a>常规实现 range 函数</h4><p>PHP 自带的 range 函数原型：</p>
<blockquote>
<p>range — 根据范围创建数组，包含指定的元素</p>
<p>array range (mixed $start , mixed $end [, number $step = 1 ])</p>
<p>建立一个包含指定范围单元的数组。</p>
</blockquote>
<p>在不使用迭代器的情况要实现一个和 PHP 自带的 <code>range</code> 函数类似的功能，可能会这么写：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span> <span class="params">($start, $end, $step = <span class="number">1</span>)</span></span></div><div class="line">&#123;</div><div class="line">    $ret = [];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        $ret[] = $i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> $ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要将生成的所有元素放在内存数组中，如果需要生成一个非常大的集合，则会占用巨大的内存。</p>
<h4 id="迭代器实现-xrange-函数"><a href="#迭代器实现-xrange-函数" class="headerlink" title="迭代器实现 xrange 函数"></a>迭代器实现 xrange 函数</h4><p>来看看迭代实现的 <code>range</code>，我们叫做 <code>xrange</code>，他实现了 <code>Iterator</code> 接口必须的 5 个方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xrange</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $start;</div><div class="line">    <span class="keyword">protected</span> $limit;</div><div class="line">    <span class="keyword">protected</span> $step;</div><div class="line">    <span class="keyword">protected</span> $current;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($start, $limit, $step = <span class="number">1</span>)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;start = $start;</div><div class="line">        <span class="keyword">$this</span>-&gt;limit = $limit;</div><div class="line">        <span class="keyword">$this</span>-&gt;step  = $step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;current = <span class="keyword">$this</span>-&gt;start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;current += <span class="keyword">$this</span>-&gt;step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current &lt;= <span class="keyword">$this</span>-&gt;limit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span> (<span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">9</span>) <span class="keyword">as</span> $key =&gt; $val) &#123;</div><div class="line">    <span class="keyword">echo</span> $key, <span class="string">' '</span>, $val, <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0 0</div><div class="line">1 1</div><div class="line">2 2</div><div class="line">3 3</div><div class="line">4 4</div><div class="line">5 5</div><div class="line">6 6</div><div class="line">7 7</div><div class="line">8 8</div><div class="line">9 9</div></pre></td></tr></table></figure>
<p>看上去功能和 <code>range()</code> 函数所做的一致，不同点在于迭代的是一个 <code>对象(Object)</code> 而不是数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var_dump(<span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">9</span>));</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">object(Xrange)#1 (4) &#123;</div><div class="line">  [&quot;start&quot;:protected]=&gt;</div><div class="line">  int(0)</div><div class="line">  [&quot;limit&quot;:protected]=&gt;</div><div class="line">  int(9)</div><div class="line">  [&quot;step&quot;:protected]=&gt;</div><div class="line">  int(1)</div><div class="line">  [&quot;current&quot;:protected]=&gt;</div><div class="line">  NULL</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，内存的占用情况也完全不同：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// range</span></div><div class="line">$startMemory = memory_get_usage();</div><div class="line">$arr = range(<span class="number">0</span>, <span class="number">500000</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'range(): '</span>, memory_get_usage() - $startMemory, <span class="string">" bytes\n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">unset</span>($arr);</div><div class="line"></div><div class="line"><span class="comment">// xrange</span></div><div class="line">$startMemory = memory_get_usage();</div><div class="line">$arr = <span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">500000</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'xrange(): '</span>, memory_get_usage() - $startMemory, <span class="string">" bytes\n"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xrange(): 624 bytes</div><div class="line">range(): 72194784 bytes</div></pre></td></tr></table></figure>
<p><code>range()</code> 函数在执行后占用了 50W 个元素内存空间，而 <code>xrange</code> 对象在整个迭代过程中只占用一个对象的内存。</p>
<h4 id="Yii2-Query"><a href="#Yii2-Query" class="headerlink" title="Yii2 Query"></a>Yii2 Query</h4><p>在喜闻乐见的各种 PHP 框架里有不少生成器的实例，比如 Yii2 中用来构建 SQL 语句的 <code>\yii\db\Query</code> 类：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$query = (<span class="keyword">new</span> \yii\db\Query)-&gt;from(<span class="string">'user'</span>);</div><div class="line"><span class="comment">// yii\db\BatchQueryResult</span></div><div class="line"><span class="keyword">foreach</span> ($query-&gt;batch() <span class="keyword">as</span> $users) &#123;</div><div class="line">    <span class="comment">// 每次循环得到多条 user 记录</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看一下 <code>batch()</code> 做了什么：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Starts a batch query.</div><div class="line">*</div><div class="line">* A batch query supports fetching data in batches, which can keep the memory usage under a limit.</div><div class="line">* This method will return a [[BatchQueryResult]] object which implements the [[\Iterator]] interface</div><div class="line">* and can be traversed to retrieve the data in batches.</div><div class="line">*</div><div class="line">* For example,</div><div class="line">*</div><div class="line">*</div><div class="line">* $query = (new Query)-&gt;from('user');</div><div class="line">* foreach ($query-&gt;batch() as $rows) &#123;</div><div class="line">*     // $rows is an array of 10 or fewer rows from user table</div><div class="line">* &#125;</div><div class="line">*</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> integer $batchSize the number of records to be fetched in each batch.</div><div class="line">* <span class="doctag">@param</span> Connection $db the database connection. If not set, the "db" application component will be used.</div><div class="line">* <span class="doctag">@return</span> BatchQueryResult the batch query result. It implements the [[\Iterator]] interface</div><div class="line">* and can be traversed to retrieve the data in batches.</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">batch</span><span class="params">($batchSize = <span class="number">100</span>, $db = null)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> Yii::createObject([</div><div class="line">       <span class="string">'class'</span> =&gt; BatchQueryResult::className(),</div><div class="line">       <span class="string">'query'</span> =&gt; <span class="keyword">$this</span>,</div><div class="line">       <span class="string">'batchSize'</span> =&gt; $batchSize,</div><div class="line">       <span class="string">'db'</span> =&gt; $db,</div><div class="line">       <span class="string">'each'</span> =&gt; <span class="keyword">false</span>,</div><div class="line">   ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上返回了一个 <code>BatchQueryResult</code> 类，类的源码实现了 <code>Iterator</code> 接口 5  个关键方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchQueryResult</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> \<span class="title">Iterator</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> $db;</div><div class="line">    <span class="keyword">public</span> $query;</div><div class="line">    <span class="keyword">public</span> $batchSize = <span class="number">100</span>;</div><div class="line">    <span class="keyword">public</span> $each = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> $_dataReader;</div><div class="line">    <span class="keyword">private</span> $_batch;</div><div class="line">    <span class="keyword">private</span> $_value;</div><div class="line">    <span class="keyword">private</span> $_key;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Destructor.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// make sure cursor is closed</span></div><div class="line">        <span class="keyword">$this</span>-&gt;reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Resets the batch query.</div><div class="line">     * This method will clean up the existing batch query so that a new batch query can be performed.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_dataReader !== <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_dataReader-&gt;close();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">$this</span>-&gt;_dataReader = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_batch = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_value = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_key = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Resets the iterator to the initial state.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;reset();</div><div class="line">        <span class="keyword">$this</span>-&gt;next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Moves the internal pointer to the next dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_batch === <span class="keyword">null</span> || !<span class="keyword">$this</span>-&gt;each || <span class="keyword">$this</span>-&gt;each &amp;&amp; next(<span class="keyword">$this</span>-&gt;_batch) === <span class="keyword">false</span>) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_batch = <span class="keyword">$this</span>-&gt;fetchData();</div><div class="line">            reset(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;each) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_value = current(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;query-&gt;indexBy !== <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key = key(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">            &#125; <span class="keyword">elseif</span> (key(<span class="keyword">$this</span>-&gt;_batch) !== <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_value = <span class="keyword">$this</span>-&gt;_batch;</div><div class="line">            <span class="keyword">$this</span>-&gt;_key = <span class="keyword">$this</span>-&gt;_key === <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">$this</span>-&gt;_key + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Fetches the next batch of data.</div><div class="line">     * <span class="doctag">@return</span> array the data fetched</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the index of the current dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> integer the index of the current row.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the current dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> mixed the current dataset.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns whether there is a valid dataset at the current position.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> boolean whether there is a valid dataset at the current position.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以迭代器的方式实现了类似分页取的效果，同时避免了一次性取出所有数据占用太多的内存空间。</p>
<h4 id="迭代器使用场景"><a href="#迭代器使用场景" class="headerlink" title="迭代器使用场景"></a>迭代器使用场景</h4><ul>
<li>使用返回迭代器的包或库时（如 PHP5 中的 SPL 迭代器）</li>
<li>无法在一次调用获取所需的所有元素时</li>
<li>要处理数量巨大的元素时（数据库中要处理的结果集内容超过内存）</li>
<li>…</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><div class="tip">需要 PHP 5 &gt;= 5.5.0 或 PHP 7</div>

<p>虽然迭代器仅需继承接口即可实现，但毕竟需要定义一整个类然后实现接口的所有方法，实在是不怎么方便。</p>
<blockquote><p>生成器则提供了一种更简单的方式来实现简单的对象迭代，相比定义类来实现 <code>Iterator</code> 接口的方式，性能开销和复杂度大大降低。</p>
<footer><strong>PHP Manual</strong></footer></blockquote>
<p>生成器允许在 <code>foreach</code> 代码块中迭代一组数据而不需要创建任何数组。一个生成器函数，就像一个普通的有返回值的自定义函数类似，但普通函数只返回一次, 而生成器可以根据需要通过 <code>yield</code> 关键字返回多次，以便连续生成需要迭代返回的值。</p>
<p>一个最简单的例子就是使用生成器来重新实现 <code>xrange()</code> 函数。效果和上面我们用迭代器实现的差不多，但实现起来要简单的多。</p>
<h4 id="生成器实现-xrange-函数"><a href="#生成器实现-xrange-函数" class="headerlink" title="生成器实现 xrange 函数"></a>生成器实现 <code>xrange</code> 函数</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start, $limit, $step = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $limit; $i += $step) &#123; </div><div class="line">        <span class="keyword">yield</span> $i + <span class="number">1</span> =&gt; $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> (xrange(<span class="number">0</span>, <span class="number">9</span>) <span class="keyword">as</span> $key =&gt; $val) &#123;</div><div class="line">    printf(<span class="string">"%d %d \n"</span>, $key, $val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="comment">// 1 0</span></div><div class="line"><span class="comment">// 2 1</span></div><div class="line"><span class="comment">// 3 2</span></div><div class="line"><span class="comment">// 4 3</span></div><div class="line"><span class="comment">// 5 4</span></div><div class="line"><span class="comment">// 6 5</span></div><div class="line"><span class="comment">// 7 6</span></div><div class="line"><span class="comment">// 8 7</span></div><div class="line"><span class="comment">// 9 8</span></div></pre></td></tr></table></figure>
<p>实际上生成器生成的正是一个迭代器对象实例，该迭代器对象继承了 <code>Iterator</code> 接口，同时也包含了生成器对象自有的接口，具体可以参考 <a href="http://php.net/manual/zh/class.generator.php" target="_blank" rel="external">Generator</a> 类的定义以及<a href="http://php.net/manual/zh/language.generators.syntax.php" target="_blank" rel="external">语法参考</a>。</p>
<p>同时需要注意的是：</p>
<div class="tip"><br>一个生成器不可以返回值，这样做会产生一个编译错误。然而 return 空是一个有效的语法并且它将会终止生成器继续执行。<br></div>

<h4 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h4><p>需要注意的是 <code>yield</code> 关键字，这是生成器的关键。通过上面的例子可以看出，<code>yield</code> 会将当前产生的值传递给 <code>foreach</code>，换句话说，<code>foreach</code> 每一次迭代过程都会从 <code>yield</code> 处取一个值，直到整个遍历过程不再能执行到 <code>yield</code> 时遍历结束，此时生成器函数简单的退出，而调用生成器的上层代码还可以继续执行，就像一个数组已经被遍历完了。</p>
<p><code>yield</code> 最简单的调用形式看起来像一个 <code>return</code> 申明，不同的是 <code>yield</code> 暂停当前过程的执行并返回值，而 <code>return</code> 是中断当前过程并返回值。暂停当前过程，意味着将处理权转交由上一级继续进行，直到上一级再次调用被暂停的过程，该过程又会从上一次暂停的位置继续执行。这像是什么呢？如果之前已经在<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">鸟哥的文章</a>中粗略看过，应该知道这很像操作系统的进程调度，多个进程在一个 CPU 核心上执行，在系统调度下每一个进程执行一段指令就被暂停，切换到下一个进程，这样外部用户看起来就像是同时在执行多个任务。</p>
<p>但仅仅如此还不够，<code>yield</code> 除了可以返回值以外，还能接收值，也就是可以在两个层级间实现<strong>双向通信</strong>。</p>
<p>来看看如何传递一个值给 <code>yield</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        printf(<span class="string">"receive: %s\n"</span>, <span class="keyword">yield</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line"></div><div class="line">$printer-&gt;send(<span class="string">'hello'</span>);</div><div class="line">$printer-&gt;send(<span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line">receive: hello</div><div class="line">receive: world</div></pre></td></tr></table></figure>
<p>根据 <a href="http://php.net/manual/zh/generator.send.php" target="_blank" rel="external">PHP 官方文档</a>的描述可以知道 <code>Generator</code> 对象除了实现 <code>Iterator</code> 接口中的必要方法以外，还有一个 <code>send</code> 方法，这个方法就是向 <code>yield</code> 语句处传递一个值，同时从 <code>yield</code> 语句处继续执行，直至再次遇到 <code>yield</code> 后控制权回到外部。</p>
<p>既然 <code>yield</code> 可以在其位置中断并返回或者接收一个值，那能不能同时进行<strong>接收</strong>和<strong>返回</strong>呢？当然，这也是实现协程的根本。对上述代码做出修改：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    $i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        printf(<span class="string">"receive: %s\n"</span>, (<span class="keyword">yield</span> ++$i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line"></div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line">$printer-&gt;send(<span class="string">'hello'</span>);</div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line">$printer-&gt;send(<span class="string">'world'</span>);</div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="number">1</span></div><div class="line">receive: hello</div><div class="line"><span class="number">2</span></div><div class="line">receive: world</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>这是另一个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;current());    <span class="comment">// string(6) "yield1"</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (第一个 var_dump)</span></div><div class="line">                              <span class="comment">// string(6) "yield2" (继续执行到第二个 yield，吐出了返回值)</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (第二个 var_dump)</span></div><div class="line">                              <span class="comment">// NULL (var_dump 之后没有其他语句，所以这次 -&gt;send() 的返回值为 null)</span></div></pre></td></tr></table></figure>
<p><code>current</code> 方法是迭代器 <code>Iterator</code> 接口必要的方法，<code>foreach</code> 语句每一次迭代都会通过其获取当前值，而后调用迭代器的 <code>next</code> 方法。在上述例子里则是手动调用了 <code>current</code> 方法获取值。</p>
<p>上述例子已经足以表示 <strong>yield</strong> 能够作为实现双向通信的工具，也就是具备了后续实现协程的基本条件。</p>
<p>上面的例子如果第一次接触并稍加思考，不免会疑惑为什么一个 <code>yield</code> 既是语句又是表达式，而且这两种情况还同时存在：</p>
<ul>
<li>对于所有在<strong>生成器</strong>函数中出现的 <code>yield</code>，首先它都是语句，而跟在 <code>yield</code> 后面的任何表达式的值将作为调用生成器函数的返回值，如果 <code>yield</code> 后面没有任何表达式（变量、常量都是表达式），那么它会返回 <code>NULL</code>，这一点和 <code>return</code> 语句一致。</li>
<li><code>yield</code> 也是表达式，它的值就是 <code>send</code> 函数传过来的值（相当于一个特殊变量，只不过赋值是通过 <code>send</code> 函数进行的）。只要调用send方法，并且生成器对象的迭代并未终结，那么当前位置的 <code>yield</code> 就会得到 <code>send</code> 方法传递过来的值，这和生成器函数有没有把这个值赋值给某个变量没有任何关系。</li>
</ul>
<p>这个地方可能需要仔细品味上面两个 <code>send()</code> 方法的例子才能理解。但可以简单的记住：</p>
<div class="tip"><br>任何时候 yield 关键词即是语句：可以为生成器函数返回值；<br>也是表达式：可以接收生成器对象发过来的值。<br></div>

<p>除了 <code>send()</code> 方法，还有一种控制生成器执行的方法是 <code>next()</code> 函数：</p>
<ul>
<li><code>Next()</code>，恢复生成器函数的执行直到下一个 <code>yield</code></li>
<li><code>Send()</code>，向生成器传入一个值，恢复执行直到下一个 <code>yield</code></li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>对于单核处理器，多进程实现多任务的原理是让操作系统给一个任务每次分配一定的 CPU 时间片，然后中断、让下一个任务执行一定的时间片接着再中断并继续执行下一个，如此反复。由于切换执行任务的速度非常快，给外部用户的感受就是多个任务的执行是同时进行的。</p>
<p>多进程的调度是由操作系统来实现的，进程自身不能控制自己何时被调度，也就是说：</p>
<blockquote>
<p>进程的调度是由外层调度器抢占式实现的</p>
</blockquote>
<p>而<strong>协程</strong>要求当前正在运行的任务自动把控制权回传给调度器，这样就可以继续运行其他任务。这与『抢占式』的多任务正好相反, 抢占多任务的调度器可以强制中断正在运行的任务, 不管它自己有没有意愿。『协作式多任务』在 Windows 的早期版本 (windows95) 和 Mac OS 中有使用, 不过它们后来都切换到『抢占式多任务』了。理由相当明确：如果仅依靠程序自动交出控制的话，那么一些恶意程序将会很容易占用全部 CPU 时间而不与其他任务共享。</p>
<blockquote>
<p>协程的调度是由协程自身主动让出控制权到外层调度器实现的</p>
</blockquote>
<p>回到刚才<strong>生成器</strong>实现 <code>xrange</code> 函数的例子，整个执行过程的交替可以用下图来表示：</p>
<img src="/2017/02/10/PHP-协程原理/14912153136517.jpg" alt="14912153136517.jpg" title="">
<p>协程可以理解为<strong>纯用户态</strong>的线程，通过协作而不是抢占来进行任务切换。相对于进程或者线程，协程所有的操作都可以在用户态而非操作系统内核态完成，创建和切换的消耗非常低。</p>
<p>简单的说 <strong>Coroutine（协程）</strong> 就是提供一种方法来中断当前任务的执行，保存当前的局部变量，下次再过来又可以恢复当前局部变量继续执行。</p>
<p>我们可以把大任务拆分成多个小任务轮流执行，如果有某个小任务在等待系统 IO，就跳过它，执行下一个小任务，这样往复调度，实现了 IO 操作和 CPU 计算的并行执行，总体上就提升了任务的执行效率，这也便是协程的意义。</p>
<h3 id="PHP-协程和-yield"><a href="#PHP-协程和-yield" class="headerlink" title="PHP 协程和 yield"></a>PHP 协程和 yield</h3><p>PHP 从 5.5 开始支持生成器及 <code>yield</code> 关键字，而 PHP 协程则由 <code>yield</code> 来实现。</p>
<p>要理解协程，首先要理解：代码是代码，函数是函数。函数包裹的代码赋予了这段代码附加的意义：不管是否显式的指明返回值，当函数内的代码块执行完后都会返回到调用层。而当调用层调用某个函数的时候，必须等这个函数返回，当前函数才能继续执行，这就构成了后进先出，也就是 <code>Stack</code>。</p>
<p>而协程包裹的代码，不是函数，不完全遵守函数的附加意义，协程执行到某个点，协会协程会 <code>yield</code> 返回一个值然后挂起，而不是 <code>return</code> 一个值然后结束，当再次调用协程的时候，会在上次 <code>yield</code> 的点继续执行。</p>
<p>所以协程违背了通常操作系统和 x86 的 CPU 认定的代码执行方式，也就是 <code>Stack</code> 的这种执行方式，需要运行环境（比如 php，python 的 yield 和 golang 的 goroutine）自己调度，来实现任务的中断和恢复，具体到 PHP，就是靠 <code>yield</code> 来实现。</p>
<p><strong>堆栈式调用</strong> 和 <strong>协程调用</strong>的对比：</p>
<img src="/2017/02/10/PHP-协程原理/14912192095503.jpg" alt="14912192095503.jpg" title="">
<p>结合之前的例子，可以总结一下 <code>yield</code> 能做的就是：</p>
<ul>
<li>实现不同任务间的主动让位、让行，把控制权交回给任务调度器。</li>
<li>通过 <code>send()</code> 实现不同任务间的双向通信，也就可以实现任务和调度器之间的通信。</li>
</ul>
<p><code>yield</code> 就是 PHP 实现协程的方式。</p>
<h3 id="协程多任务调度"><a href="#协程多任务调度" class="headerlink" title="协程多任务调度"></a>协程多任务调度</h3><p>下面是雄文 <a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">Cooperative multitasking using coroutines (in PHP!)</a> 里一个简单但完整的例子，来展示如何具体的在 PHP 里实现协程任务的调度。</p>
<p>首先是一个任务类：</p>
<p><strong>Task</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 任务 ID</span></div><div class="line">    <span class="keyword">protected</span> $taskId;</div><div class="line">    <span class="comment">// 协程对象</span></div><div class="line">    <span class="keyword">protected</span> $coroutine;</div><div class="line">    <span class="comment">// send() 值</span></div><div class="line">    <span class="keyword">protected</span> $sendVal = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 是否首次 yield</span></div><div class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</div><div class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendVal)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;sendVal = $sendVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 如之前提到的在send之前, 当迭代器被创建后第一次 yield 之前，一个 renwind() 方法会被隐式调用</span></div><div class="line">        <span class="comment">// 所以实际上发生的应该类似:</span></div><div class="line">        <span class="comment">// $this-&gt;coroutine-&gt;rewind();</span></div><div class="line">        <span class="comment">// $this-&gt;coroutine-&gt;send();</span></div><div class="line">         </div><div class="line">        <span class="comment">// 这样 renwind 的执行将会导致第一个 yield 被执行, 并且忽略了他的返回值.</span></div><div class="line">        <span class="comment">// 真正当我们调用 yield 的时候, 我们得到的是第二个yield的值，导致第一个yield的值被忽略。</span></div><div class="line">        <span class="comment">// 所以这个加上一个是否第一次 yield 的判断来避免这个问题</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendVal);</div><div class="line">            <span class="keyword">$this</span>-&gt;sendVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> $retval;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是调度器，比 <code>foreach</code> 是要复杂一点，但好歹也能算个正儿八经的 <code>Scheduler</code> :)</p>
<p><strong>Scheduler</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $taskQueue;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// （使用下一个空闲的任务id）创建一个新任务,然后把这个任务放入任务map数组里. 接着它通过把任务放入任务队列里来实现对任务的调度. 接着run()方法扫描任务队列, 运行任务.如果一个任务结束了, 那么它将从队列里删除, 否则它将在队列的末尾再次被调度。</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</div><div class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</div><div class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;</div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $tid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">    	<span class="comment">// 任务入队</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty()) &#123;</div><div class="line">        	<span class="comment">// 任务出队</span></div><div class="line">            $task = <span class="keyword">$this</span>-&gt;queue-&gt;dequeue();</div><div class="line">            $task-&gt;run();</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>队列可以使每个任务获得同等的 CPU 使用时间，</p>
<p><strong>Demo</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"> </div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line"> </div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">This is task 1 iteration 1.</div><div class="line">This is task 2 iteration 1.</div><div class="line">This is task 1 iteration 2.</div><div class="line">This is task 2 iteration 2.</div><div class="line">This is task 1 iteration 3.</div><div class="line">This is task 2 iteration 3.</div><div class="line">This is task 1 iteration 4.</div><div class="line">This is task 2 iteration 4.</div><div class="line">This is task 1 iteration 5.</div><div class="line">This is task 2 iteration 5.</div><div class="line">This is task 1 iteration 6.</div><div class="line">This is task 1 iteration 7.</div><div class="line">This is task 1 iteration 8.</div><div class="line">This is task 1 iteration 9.</div><div class="line">This is task 1 iteration 10.</div></pre></td></tr></table></figure>
<p>结果正是我们期待的，最初的 5 次迭代，两个任务是交替进行的，而在第二个任务结束后，只有第一个任务继续执行到结束。</p>
<h3 id="协程非阻塞-IO"><a href="#协程非阻塞-IO" class="headerlink" title="协程非阻塞 IO"></a>协程非阻塞 IO</h3><p>若想真正的发挥出协程的作用，那一定是在一些涉及到阻塞 IO 的场景，我们都知道 Web 服务器最耗时的部分通常都是 socket 读取数据等操作上，如果进程对每个请求都挂起的等待 IO 操作，那处理效率就太低了，接下来我们看个支持非阻塞 IO 的 Scheduler：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">protected</span> $tasks = []; <span class="comment">// taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $queue;</div><div class="line"></div><div class="line">    <span class="comment">// resourceID =&gt; [socket, tasks]</span></div><div class="line">    <span class="keyword">protected</span> $waitingForRead = [];</div><div class="line">    <span class="keyword">protected</span> $waitingForWrite = [];</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// SPL 队列</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</div><div class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</div><div class="line">        <span class="keyword">$this</span>-&gt;tasks[$tid] = $task;</div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $tid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">    	<span class="comment">// 任务入队</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty()) &#123;</div><div class="line">        	<span class="comment">// 任务出队</span></div><div class="line">            $task = <span class="keyword">$this</span>-&gt;queue-&gt;dequeue();</div><div class="line">            $task-&gt;run();</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;tasks[$task-&gt;getTaskId()]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span><span class="params">($socket, Task $task)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket])) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket][<span class="number">1</span>][] = $task;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket] = [$socket, [$task]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span><span class="params">($socket, Task $task)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket])) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket][<span class="number">1</span>][] = $task;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket] = [$socket, [$task]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> $timeout 0 represent</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPoll</span><span class="params">($timeout)</span></span></div><div class="line">    &#123;</div><div class="line">        $rSocks = [];</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForRead <span class="keyword">as</span> <span class="keyword">list</span>($socket)) &#123;</div><div class="line">            $rSocks[] = $socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $wSocks = [];</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForWrite <span class="keyword">as</span> <span class="keyword">list</span>($socket)) &#123;</div><div class="line">            $wSocks[] = $socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $eSocks = [];</div><div class="line">        <span class="comment">// $timeout 为 0 时, stream_select 为立即返回，为 null 时则会阻塞的等，见 http://php.net/manual/zh/function.stream-select.php</span></div><div class="line">        <span class="keyword">if</span> (!@stream_select($rSocks, $wSocks, $eSocks, $timeout)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> ($rSocks <span class="keyword">as</span> $socket) &#123;</div><div class="line">            <span class="keyword">list</span>(, $tasks) = <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket];</div><div class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket]);</div><div class="line"></div><div class="line">            <span class="keyword">foreach</span> ($tasks <span class="keyword">as</span> $task) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> ($wSocks <span class="keyword">as</span> $socket) &#123;</div><div class="line">            <span class="keyword">list</span>(, $tasks) = <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket];</div><div class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket]);</div><div class="line"></div><div class="line">            <span class="keyword">foreach</span> ($tasks <span class="keyword">as</span> $task) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 检查队列是否为空，若为空则挂起的执行 stream_select，否则检查完 IO 状态立即返回，详见 ioPoll()</div><div class="line">     * 作为任务加入队列后，由于 while true，会被一直重复的加入任务队列，实现每次任务前检查 IO 状态</div><div class="line">     * <span class="doctag">@return</span> Generator object for newTask</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPollTask</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;ioPoll(<span class="keyword">null</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;ioPoll(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">yield</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * $scheduler = new Scheduler;</div><div class="line">     * $scheduler-&gt;newTask(Web Server Generator);</div><div class="line">     * $scheduler-&gt;withIoPoll()-&gt;run();</div><div class="line">     *</div><div class="line">     * 新建 Web Server 任务后先执行 withIoPoll() 将 ioPollTask() 作为任务入队</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> $this</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">withIoPoll</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;newTask(<span class="keyword">$this</span>-&gt;ioPollTask());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个版本的 Scheduler 里加入一个永不退出的任务，并且通过 <code>stream_select</code> 支持的特性来实现快速的来回检查各个任务的 IO 状态，只有 IO 完成的任务才会继续执行，而 IO 还未完成的任务则会跳过，完整的代码和例子可以<a href="https://github.com/Jamlee/coroutine" target="_blank" rel="external">戳这里</a>。</p>
<p>也就是说任务交替执行的过程中，一旦遇到需要 IO 的部分，调度器就会把 CPU 时间分配给不需要 IO 的任务，等到当前任务遇到 IO 或者之前的任务 IO 结束才再次调度 CPU 时间，以此实现 CPU 和 IO 并行来提升执行效率，类似下图：</p>
<img src="/2017/02/10/PHP-协程原理/14913877605869.jpg" alt="14913877605869.jpg" title="">
<h3 id="单任务改造"><a href="#单任务改造" class="headerlink" title="单任务改造"></a>单任务改造</h3><p>如果想将一个单进程任务改造成并发执行，我们可以选择改造成多进程或者协程：</p>
<ul>
<li><strong>多进程</strong>，不改变任务执行的整体过程，在一个时间段内同时执行多个相同的代码段，调度权在 CPU，如果一个任务能独占一个 CPU 则可以实现并行。</li>
<li><strong>协程</strong>，把原有任务拆分成多个小任务，原有任务的执行流程被改变，调度权在进程自己，如果有 IO 并且可以实现异步，则可以实现并行。</li>
</ul>
<p><strong>多进程改造</strong></p>
<img src="/2017/02/10/PHP-协程原理/14914233052018.jpg" alt="14914233052018.jpg" title="">
<p><strong>协程改造</strong></p>
<img src="/2017/02/10/PHP-协程原理/14914233296912.jpg" alt="14914233296912.jpg" title="">
<h2 id="协程（Coroutines）和-Go-协程（Goroutines）"><a href="#协程（Coroutines）和-Go-协程（Goroutines）" class="headerlink" title="协程（Coroutines）和 Go 协程（Goroutines）"></a>协程（Coroutines）和 Go 协程（Goroutines）</h2><p>PHP 的协程或者其他语言中，比如 Python、Lua 等都有协程的概念，和 Go 协程有些相似，不过有两点不同：</p>
<ul>
<li>Go 协程意味着并行（或者可以以并行的方式部署，可以用 <code>runtime.GOMAXPROCS()</code> 指定可同时使用的 CPU 个数），协程一般来说只是并发。</li>
<li>Go 协程通过通道 <code>channel</code> 来通信；协程通过 <code>yield</code> 让出和恢复操作来通信。</li>
</ul>
<p>Go 协程比普通协程更强大，也很容易从协程的逻辑复用到 Go 协程，而且在 Go 的开发中也使用的极为普遍，有兴趣的话可以了解一下作为对比。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>个人感觉 PHP 的协程在实际使用中想要徒手实现和应用并不方便而且场景有限，但了解其概念及实现原理对更好的理解并发不无裨益。</p>
<p>如果想更多的了解协程的实际应用场景不妨试试已经大名鼎鼎的 <a href="https://wiki.swoole.com/wiki/page/p-coroutine.html" target="_blank" rel="external">Swoole</a>，其对多种协议的 client 做了底层的协程封装，几乎可以做到以同步编程的写法实现协程异步 IO 的效果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">在PHP中使用协程实现多任务调度</a></li>
<li><a href="http://rango.swoole.com/archives/508" target="_blank" rel="external">PHP 并发 IO 编程之路</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现 PHP 协程需要了解的基本内容。&lt;br&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://newton.sh/tags/PHP/"/>
    
      <category term="Coroutine" scheme="http://newton.sh/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>如何避开 Go 中的各种陷阱</title>
    <link href="http://newton.sh/2016/11/07/%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80-Go-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%99%B7%E9%98%B1/"/>
    <id>http://newton.sh/2016/11/07/如何避开-Go-中的各种陷阱/</id>
    <published>2016-11-07T09:34:28.000Z</published>
    <updated>2017-04-13T06:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于几种基本数据类型的内部实现，讨论 Go 里有哪些新手容易掉进去的 “坑“。<br><a id="more"></a></p>
<blockquote>
<p>原文：<a href="https://divan.github.io/posts/avoid_gotchas/" target="_blank" rel="external">How to avoid Go gotchas</a></p>
</blockquote>
<h5 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h5><p>维基百科对「坑」的定义（原文中叫 <code>Gotcha</code>）：</p>
<blockquote>
<p>a gotcha is a valid construct in a system, program or programming language that works as documented but is counter-intuitive and almost invites mistakes because it is both easy to invoke and unexpected or unreasonable in its outcome<br>(source: <a href="https://en.wikipedia.org/wiki/Gotcha_(programming" target="_blank" rel="external">wikipedia</a>))</p>
</blockquote>
<p>Go 语言有一些我们常说的「坑」，有<a href="https://go-traps.appspot.com" target="_blank" rel="external">不少</a>优秀的<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html" target="_blank" rel="external">文章</a>讨论过这些「坑」。这些文章所讨论的东西非常重要，尤其对 Go 的初学者来说，一不小心就掉进了这些「坑」里。</p>
<p>但有个问题让我困惑了很久，为什么我几乎没碰到过这些文章里讨论的大部分「坑」？真的，大多数比较知名的比如 “nil interface” 或者 “slice append” 等我从来就没觉得困惑过。我从开始使用 Go 一直到现在总是以某种方式避开了这些形形色色的问题。</p>
<p>后来发现，我足够幸运的读了不少解释 Go 数据结构内部实现的文章并且学习了一些 Go 内部运行原理的基础知识。这些知识足够让我对 Go 有了深刻的认识，同时也避免了掉进各种各样的坑里。</p>
<p>记住维基百科的定义，<em>「坑 是…有效的构造…但同时是反直觉的」</em><br>所以，你只有两个选项：</p>
<ul>
<li>“fix” 这门语言</li>
<li>fix 自己的直觉</li>
</ul>
<p>第二种显然是更好的选择，一旦你脑中有了一副清晰的图像描绘了切片或者接口在底层是如何运作的，根本不可能再掉进那些陷阱里。</p>
<p>这样的学习方式对我而言是有用的，我想对其他人也同样适用。这也是为什么我决定在这篇文章里整理一些关于 Go 内部实现的基础知识，希望能帮助其他人对各种数据结构在内存中的表示建立起清晰的直觉。</p>
<p>让我们从一些基础的开始：</p>
<ul>
<li><a href="#pointers">指针 (Pointers)</a></li>
<li><a href="#arrays-and-slices">数组和切片 (Arrays and slices)</a></li>
<li><a href="#append">Append</a> </li>
<li><a href="#interfaces">接口 (Interfaces)</a></li>
<li><a href="#empty-interface">空接口 (Empty interface)</a></li>
</ul>
<h1 id="指针-Pointers"><a href="#指针-Pointers" class="headerlink" title="指针 (Pointers)"></a>指针 (Pointers)</h1><p>Go 实际上是一门在层次上非常接近硬件的语言。当你创建一个 64 位的整形变量（<code>int64</code>）你就精确的知道它占用了多少内存，而且可以用 <a href="https://golang.org/pkg/unsafe/#Sizeof" target="_blank" rel="external">unsafe.Sizeof()</a> 方法来计算每种类型的内存占用量。</p>
<p>我经常用可视化的内存块来「看」这些变量、数组和数据结构的大小。视觉上的展示可以让人更直观的理解这些类型，也便于解释一些行为和性能上的问题。</p>
<p>作为热身，我们先对 Go 里最基础的类型做可视化：  </p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/basic_types.png" alt="基础类型" title="基础类型">
<p>假设你在一台 32 位的机器上 <em>(我知道现在你可能只有 64 位的机器了…)</em>, 可以清楚的看到 <code>int64</code> 的内存占用是 <code>int32</code> 的两倍。</p>
<p>指针的内部表示稍微复杂一点，它占用一块内存，包含了一个指向其他内存块的内存地址，这个地址存储着实际的数据。有个术语叫 <em>『引用指针』</em> ，实际上它指的是 <em>『通过存储在指针变量里的地址取到实际指向的内存块』</em>。可以想象一下指针在内存中的表示：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/pointers.png" alt="指针" title="指针">
<p>地址在内存里通常用十六进制表示，像图中标识的 <em>“0x…”</em> 这样。先记住，『指针的值』存放在一个地方，『指针指向的数据』存放在另一个地方，这一点会有助于我们后面的理解。</p>
<p>对于没有指针相关知识的 Go 新手来说，很容混淆值函数参数的『值传递』。你可能已经知道，Go 里所有的传参都是『按值』传递，也就是通过复制来实现传参。<br>图示如下：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/func_params.png" alt="函数参数" title="函数参数">
<p>在第一个例子里，复制了所有的内存块 - 但实际情况里用到的变量基本都会超过 2 个甚至 200 万个内存块，如果全部都复制一份的话将会是成本非常高的操作。而在第二个例子里，只需要复制包含了实际数据内存地址的那一块内存，这样做非常高效而且成本很低。</p>
<p>显然，第一个例子里如果改变 <code>Foo()</code> 方法中的 <code>p</code> 变量并不会修改原始数据的内容，但在第二个例子里则肯定会修改 <code>p</code> 所指向的原始数据的内存块。</p>
<p>理解了关键的内部实现将会帮你避开大多数的坑，接下来让我们再深入一点。</p>
<h1 id="数组和切片-Arrays-and-Slices"><a href="#数组和切片-Arrays-and-Slices" class="headerlink" title="数组和切片 (Arrays and Slices)"></a>数组和切片 (Arrays and Slices)</h1><p>初学的时候一般都会对切片和数组感到混淆和困惑。所以我们先来看看数组。</p>
<h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 (Arrays)"></a>数组 (Arrays)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></div><div class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line"><span class="keyword">var</span> arr [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div></pre></td></tr></table></figure>
<p>数组只是连续的内存块，如果你去阅读 Go 运行时的源码(<a href="https://golang.org/src/runtime/malloc.go#L793" target="_blank" rel="external">src/runtime/malloc.go</a>)，你会发现创建一个数组本质上就是分配了一块指定大小的内存。是不是想到了经典的 <code>malloc</code>？在 Go 里只是更加智能了。</p>
<blockquote>
<p>Old good malloc, just smarter :)  </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// newarray allocates an array of n elements of type typ.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newarray</span><span class="params">(typ *_type, n <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> || <span class="keyword">uintptr</span>(n) &gt; maxSliceCap(typ.size) &#123;</div><div class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"runtime: allocation size out of range"</span>))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mallocgc(typ.size*<span class="keyword">uintptr</span>(n), typ, <span class="literal">true</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这意味着我们可以简单的用一组通过指针连接起来的内存块来表示一个数组：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/array.png" alt="数组" title="数组">
<p>数组元素总是会初始化为指定类型的 <strong>零值</strong>，在我们的例子里，<code>[5]int</code> 的初始化值为 <code>0</code>。我们可以通过索引下标取到数组里的每个元素，也可以通过内置函数 <code>len()</code> 来得到数组长度。</p>
<p>当你通过下标索引到数组里的某个元素并且做下面这样的操作时：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span></div><div class="line">arr[<span class="number">4</span>] = <span class="number">42</span></div></pre></td></tr></table></figure>
<p>你会取到第五个（4+1）元素并且改变它的值：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/array2.png" alt="数组" title="数组">
<p>现在，我们已经准备好来探索一下切片。</p>
<h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p>切片一眼看上去和数组很像，就连声明的语法也差不多：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo []<span class="keyword">int</span></div></pre></td></tr></table></figure>
<p>但如果我们阅读一下 Go 的源码就会发现（<a href="https://golang.org/src/runtime/slice.go#L11" target="_blank" rel="external">src/runtime/slice.go</a>）实际上切片的数据结构包括 3 个部分 - 指向数组的指针、切片的长度和切片的容量：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</div><div class="line">    array unsafe.Pointer</div><div class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></div><div class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当创建一个新的切片时，Go 运行时会在内存里创建这样一个包含 3 块区域的对象，并且会把数组指针初始化为 <code>nil</code>，<code>len</code> 和 <code>cap</code> 初始化为 <code>0</code>。让我们来看看它的可视化表示：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/slice1.png" alt="切片-1" title="切片-1">
<p>可以用 <code>make</code> 来初始化一个指定大小的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>这段代码会创建一个切片，包含了一个 5 个元素的数组，每个元素的初值为 0，<code>len</code> 和 <code>cap</code> 的初值则为 5。<br>Cap 是指切片大小可以达到的上限，以便为未来可能的增长留出空间。可以用 <code>make([]int, len, cap)</code> 语法来指定容量。实际使用中你很可能永远不用去特别在意它，但这对我们理解容量的概念来说很重要。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>下面是两个例子：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/slice2.png" alt="切片-2" title="切片-2">
<p>如果你要更改切片中某些元素的值，实际上是在改变切片指向的数组元素的值。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">foo[<span class="number">3</span>] = <span class="number">42</span></div><div class="line">foo[<span class="number">4</span>] = <span class="number">100</span></div></pre></td></tr></table></figure>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/slice3.png" alt="切片-3" title="切片-3">
<p>这很好理解。让我们把情况弄得稍微复杂一点，在原切片的基础上创建一个子切片，然后改变子切片里元素的值？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">foo[<span class="number">3</span>] = <span class="number">42</span></div><div class="line">foo[<span class="number">4</span>] = <span class="number">100</span></div><div class="line">bar  := foo[<span class="number">1</span>:<span class="number">4</span>]</div><div class="line">bar[<span class="number">1</span>] = <span class="number">99</span></div></pre></td></tr></table></figure>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/slice4.png" alt="切片-4" title="切片-4">
<p>通过图示可以看到，我们更改了 <code>bar</code> 的元素值，实际上是改变了它所指向数组里的元素值，也就是 <code>foo</code> 也同时指向的那个数组。真实的情况也的确是这样，你可能会写出下面这样的代码：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</div><div class="line">    b, _ := ioutil.ReadFile(filename)</div><div class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设我们读取了 <code>10MB</code> 的数据放到切片中，但只在其中查找 <code>3 个数字</code>，直觉上我们可能会觉得这个操作只会返回 <code>3 个字节</code> 的数据，但恰恰相反，切片指向的数组不管容量多大都会整个保存在内存中。  </p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/slice5.png" alt="切片-5" title="切片-5">
<p>这关于 Go 切片的一个很常见的坑，你很可能无法准确的预料为了使用这个切片到底耗费了多少内存。但一旦你脑海里有了关于切片内部实现的可视化表示，我敢打赌几乎下次遇到这样的场景时你会信心十足。</p>
<h1 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h1><p>聊完切片本身，接下来我们看看切片的内置函数 <code>append()</code> 。它本质上的功能就是把一个元素值添加到切片中，但在内部实现里，为了在必要的时候做到智能高效的分配内存，它还做了不少复杂的操作。</p>
<p>看看下面这段代码:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</div><div class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>还记得 <code>cap</code> - 切片的容量么？容量代表着 <em>切片可以达到的最大容量</em>。<code>append</code> 会检查切片的容量是否还允许扩展，如果可以则为切片分配更多的内存。分配内存是一个开销非常大的操作，所以当你使用 <code>append</code> 向切片添加一个 1 字节大小的元素，实际上 <code>append</code> 会尝试一次分配 32 字节，且每次扩容都会是原有容量的两倍。这是因为一次分配更多的内存通常都比多次分配少量内存的开销更小且速度更快。</p>
<p>这里令人困惑的是，由于各种原因，通常情况下分配更多的内存意味着首先在一个不同的内存地址申请一块新的足够大的内存空间，然后从当前的内存地址把数据复制到新的内存块中。也就是说切片所指向的数组的地址也会被改变。可视化表示如下：</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/append.png" alt="append.png" title="">
<p>很显然这样就会存在两个被指向的数组，原有的和新分配的。是不是嗅到了一丝「坑」的味道？原来的数组如果没有被其他的切片指向的话稍后就会被垃圾回收机制释放掉。在这个例子里，实际上就存在一个 append 操作引发的坑。如果我们创建了一个子切片 <code>b</code>，然后对 <code>a</code> 切片 append 一个值，这两个切片还会共同指向同一个数组么？  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</div><div class="line">b := a[<span class="number">1</span>:<span class="number">16</span>]</div><div class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</div><div class="line">a[<span class="number">2</span>] = <span class="number">42</span></div></pre></td></tr></table></figure>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/append2.png" alt="append2.png" title="">
<p>（译者注：图中 <code>b</code> 的 <code>cap</code> 值应为 31，子切片的 <code>cap</code> 应该等于起始位置到父切片末尾的容量）</p>
<p>通过图示结合我们上面所说的，切片 <code>a</code> 和 <code>b</code> 会分别指向两个不同的数组，这对初学者来说可能有点反直觉。所以，使用子切片的时候要格外小心，尤其是伴随着 append 操作的时候，这算是一条经验之谈。</p>
<div class="tip"><br><code>append</code> 对切片扩容时，如果大小在 1024 字节以内，每次都会以双倍的大小来申请内存，但如果超过了 1024 字节则会使用所谓的 <a href="https://golang.org/src/runtime/msize.go" target="_blank" rel="external">memory size classes</a> 来保证增长的容量不会大于当前容量的 12.5%。因为对于大小为 32 字节的数组一次请求 64 字节的内存是没什么问题的，但如果切片的容量为 4GB 或更多，这时候添加一个新元素如果直接多分配出 4GB 的内存则显得代价太大，上面的规则就是考虑到了这样的情况。<br></div>

<h1 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h1><p>这是对很多人来说最容易困惑的部分。需要花费不少时间来掌握和理解如何在 Go 里正确的使用接口，尤其是对在其他面向对象语言里有着惨痛经验的程序员来说。造成这种困惑的一个根源就是 <code>nil</code> 这个关键字在接口的上下文里会总是有着不同的含义。</p>
<p>为了理解这一部分，让我们再来看看源码。<br>接口的底层实现里到底有什么？这里是一段源码 <a href="https://golang.org/src/runtime/runtime2.go#L143" target="_blank" rel="external">src/runtime/runtime2.go</a> 的摘抄：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</div><div class="line">    tab  *itab</div><div class="line">    data unsafe.Pointer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>itab</code> 表示 <em>interface table</em>，它是一个保存接口和底层类型所需元数据的数据结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter  *interfacetype</div><div class="line">    _type  *_type</div><div class="line">    link   *itab</div><div class="line">    bad    <span class="keyword">int32</span></div><div class="line">    unused <span class="keyword">int32</span></div><div class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// 变量大小</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们并不打算深究接口类型断言的实现逻辑，但重要的是要理解 <em>interface</em> 是接口和静态类型信息加上指向实际变量的指针的复合体（<code>iface</code> 中的 <code>data</code> 字段）。我们来创建一个接口类型 <code>error</code> 的变量 <code>err</code> 并把它的结构可视化：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err error</div></pre></td></tr></table></figure>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/iface1.png" alt="iface1.png" title="">
<p>这张图里所展示的东西实际上就是传说中的 <em>nil interface</em>。当你在方法里返回 <code>error</code> 类型时，你返回的就是这个对象。它包含了接口的信息（<code>itab.inter</code>），但 <code>data</code> 字段和 <code>itab.type</code> 的值为 <code>nil</code>。当你使用 <code>if err == nil {}</code> 做判断时，这个对象会被判定为 <code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> err error <span class="comment">// nil</span></div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line">err := foo()</div><div class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;...&#125; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>一个广为人知的「坑」就是当你返回一个值为 <code>nil</code> 的 <code>*os.PathError</code> 类型变量时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> err *os.PathError <span class="comment">// nil</span></div><div class="line">    <span class="keyword">return</span> err</div><div class="line">&#125;</div><div class="line">err := foo()</div><div class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;...&#125; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>除非清楚的知道内存里接口的内部结构是什么样，否则上面这两段代码看起来几乎没有区别。现在来看看 <code>nil</code> 值的 <code>*os.PathError</code> 类型变量是如何被包裹在 <code>error</code> 接口里的。</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/iface2.png" alt="iface2.png" title="">
<p>可以清楚的看到 <code>*os.PathError</code> - 只是一块存放了 <code>nil</code> 值的内存块，因为指针的零值就是 <code>nil</code>。但实际上 <code>foo()</code> 返回的 <code>error</code> 是一个包含了关于接口、接口类型、以及存放了 <code>nil</code> 值的内存地址等信息的更复杂的结构。发现不一样的地方了么？</p>
<p>在上面两个例子里，我们都创建了 <code>nil</code>，但在 <em>包含了一个值为 <code>nil</code> 的变量的接口</em> 和 <em>不包含变量的接口</em> 间存在着巨大的区别。有了这样对接口内部结构的认识，再来看看这两个例子容易混淆的例子：  </p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/iface3.png" alt="iface3.png" title="">
<p>现在应该对类似的问题不会再感到困惑了。</p>
<h3 id="空接口（Empty-interface）"><a href="#空接口（Empty-interface）" class="headerlink" title="空接口（Empty interface）"></a>空接口（Empty interface）</h3><p>接下来我们来说说 <em>空接口（empty interface）</em> - <code>interface{}</code>。在 Go 的源码中 (<a href="https://golang.org/src/runtime/runtime2.go#L148" target="_blank" rel="external">src/runtime/malloc.go</a> 用了一个自有的结构 <code>eface</code> 来实现：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</div><div class="line">    _type *_type</div><div class="line">    data  unsafe.Pointer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它和 <code>iface</code> 很像，不过缺少接口表 <code>interface table</code>。因为从定义上讲空接口由任意静态类型实现,所以 <code>eface</code> 并不需要接口表。当你尝试显示或隐式地（比如当做方法参数传递）封装一些东西到 <code>interface{}</code> 时，内存里存储的实际上是这样的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    foo := <span class="keyword">int64</span>(<span class="number">42</span>)</div><div class="line">    <span class="keyword">return</span> foo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/eface.png" alt="eface.png" title="">
<p>空接口 <code>interface{}</code> 有个比较蛋疼的问题是，不能方便的把接口切片赋值给混合类型的切片，反之亦然。比如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码将导致一个编译错误：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go build</div><div class="line">cannot use []int literal (<span class="built_in">type</span> []int) as <span class="built_in">type</span> []interface &#123;&#125; <span class="keyword">in</span> <span class="built_in">return</span> argument</div></pre></td></tr></table></figure>
<p>一开始这会很令人困惑。为什么我们可以在单个变量时直接做转换，而在切片类型里却不行？一旦我们知道了空接口本质上是什么（再看一眼上面的图示），就会十分清楚缘由，这样的『转换』实在是一个成本非常高的操作，涉及到分配大量的内存以及 O(n) 左右的时间和空间复杂度。而且 Go 的设计原则中有一条就是 <strong>如果需要做一些开销很大的操作 - 光明正大的做（显式而非隐式的做）</strong>。</p>
<img src="/2016/11/07/如何避开-Go-中的各种陷阱/eface_slice.png" alt="eface_slice.png" title="">
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>不是每个坑都需要通过学习 Go 的内部实现来了解透彻。有一些仅仅只是因为过去的经验和 Go 的玩法有些不一样，毕竟我们每个人或多或少都有着不同的背景和经验。不过，只要稍微深入的理解 Go 的内部工作原理，就能避免掉进绝大多数陷阱里。<br>希望本篇文章里的各种解释可以帮大家建立起对 Go 程序内部运行机制的直觉印象，相信这些知识可以帮助我们成为更棒的开发者。Go 是人类的好朋友，了解更多一点更深一点并不会有什么损失 :)</p>
<p>如果还想更多的了解 Go 的内部实现，我精选了一些文章列在这里：</p>
<ul>
<li><a href="http://research.swtch.com/godata" target="_blank" rel="external">Go Data Structures</a></li>
<li><a href="http://research.swtch.com/interfaces" target="_blank" rel="external">Go Data Structures: Interfaces</a></li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="external">Go Slices: usage and internals</a></li>
<li><a href="http://talks.godoc.org/github.com/davecheney/presentations/gopher-puzzlers.slide" target="_blank" rel="external">Gopher Puzzlers</a></li>
</ul>
<p>当然，怎么也不能忘了这些只传有缘人的宝典 :)</p>
<ul>
<li><a href="https://golang.org/src/" target="_blank" rel="external">Go source code</a></li>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a></li>
<li><a href="https://golang.org/ref/spec" target="_blank" rel="external">Go spec</a></li>
</ul>
<p>Happy hacking!</p>
<p>另外，作者 11 月 16 号做了一个相关的分享 <a href="http://www.meetup.com/Golang-Barcelona/" target="_blank" rel="external">Golang BCN</a> 。</p>
<p>有兴趣的可以看看这次分享的幻灯片: <a href="http://divan.github.io/talks/2016/bcn/HowToAvoidGoGotchas.pdf" target="_blank" rel="external">How To Avoid Go Gotchas.pdf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于几种基本数据类型的内部实现，讨论 Go 里有哪些新手容易掉进去的 “坑“。&lt;br&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://newton.sh/tags/Go/"/>
    
  </entry>
  
</feed>
