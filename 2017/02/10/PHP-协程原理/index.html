<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PHP 协程原理 · newton.log</title><meta name="description" content="PHP 协程原理 - Newton"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="newton.log"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/newt0n" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://instagram.com/newtonjin" target="_blank" class="nav-list-link">INSTAGRAM</a></li><li class="nav-list-item"><a href="https://www.douban.com/people/Mr.Jin" target="_blank" class="nav-list-link">DOUBAN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">PHP 协程原理</h1><div class="post-info">Feb 10, 2017</div><div class="post-content"><h2 id="多进程-线程"><a href="#多进程-线程" class="headerlink" title="多进程/线程"></a>多进程/线程</h2><p>最早的服务器端程序都是通过多进程、多线程来解决并发IO的问题。进程模型出现的最早，从Unix 系统诞生就开始有了进程的概念。最早的服务器端程序一般都是 Accept 一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞地与客户端连接进行交互，收发处理数据。</p>
<p>多线程模式出现要晚一些，线程与进程相比更轻量，而且线程之间共享内存堆栈，所以不同的线程之间交互非常容易实现。比如实现一个聊天室，客户端连接之间可以交互，聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存等等统称进程间通信（IPC）复杂的技术才能实现。</p>
<p><strong>最简单的多进程服务端模型</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0:8000"</span>, $errno, $errstr) </div><div class="line"><span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Create server failed"</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">	$conn = stream_socket_accept($serv);</div><div class="line">	<span class="keyword">if</span> (pcntl_fork() == <span class="number">0</span>) &#123;</div><div class="line">		$request = fread($conn);</div><div class="line">		<span class="comment">// do something</span></div><div class="line">		<span class="comment">// $response = "hello world";</span></div><div class="line">		fwrite($response);</div><div class="line">		fclose($conn);</div><div class="line">		<span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>多进程/线程模型的流程是：</p>
<p>创建一个 <code>socket</code>，绑定服务器端口（<code>bind</code>），监听端口（<code>listen</code>），在 PHP 中用 <code>stream_socket_server</code> 一个函数就能完成上面 3 个步骤，当然也可以使用更底层的<code>sockets</code> 扩展分别实现。</p>
<p>进入 <code>while</code> 循环，阻塞在 <code>accept</code> 操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起 <code>connect</code> 到服务器，操作系统会唤醒此进程。<code>accept</code> 函数返回客户端连接的 <code>socket</code> 主进程在多进程模型下通过 <code>fork</code>（php: pcntl_fork）创建子进程，多线程模型下使用 <code>pthread_create</code>（php: new Thread）创建子线程。</p>
<p>下文如无特殊声明将使用进程同时表示进程/线程。</p>
<p>子进程创建成功后进入 <code>while</code> 循环，阻塞在 <code>recv</code>（php:fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用 <code>send</code>（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会 <code>close</code>。</p>
<p>当客户端连接关闭时，子进程退出并销毁所有资源，主进程会回收掉此子进程。</p>
<img src="/2017/02/10/PHP-协程原理/14906085938366.jpg" alt="14906085938366.jpg" title="">
<p>这种模式最大的问题是，进程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的 <code>Leader-Follower</code> 模型。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0:8000"</span>, $errno, $errstr) </div><div class="line"><span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Create server failed"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">32</span>; $i++) &#123;</div><div class="line">    <span class="keyword">if</span> (pcntl_fork() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">            $conn = stream_socket_accept($serv);</div><div class="line">            <span class="keyword">if</span> ($conn == <span class="keyword">false</span>) <span class="keyword">continue</span>;</div><div class="line">            <span class="comment">// do something</span></div><div class="line">            $request = fread($conn);</div><div class="line">            <span class="comment">// $response = "hello world";</span></div><div class="line">            fwrite($response);</div><div class="line">            fclose($conn);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的特点是程序启动后就会创建 N 个进程。每个子进程进入 <code>Accept</code>，等待新的连接进入。当客户端连接到服务器时，其中一个子进程会被唤醒，开始处理客户端请求，并且不再接受新的 TCP 连接。当此连接关闭时，子进程会释放，重新进入 <code>Accept</code>，参与处理新的连接。</p>
<p>这个模型的优势是完全可以复用进程，没有额外消耗，性能非常好。很多常见的服务器程序都是基于此模型的，比如 Apache、PHP-FPM。</p>
<p>多进程模型也有一些缺点。</p>
<p>这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。</p>
<p>启动大量进程会带来额外的进程调度消耗。数百个进程时可能进程上下文切换调度消耗占 CPU 不到1%可以忽略不接，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到 CPU 的百分之几十甚至 100%。</p>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>谈到多进程以及类似同时执行多个任务的模型，就不得不先谈谈并行和并发。</p>
<h3 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h3><p>是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</p>
<h3 id="并行（Parallesim）"><a href="#并行（Parallesim）" class="headerlink" title="并行（Parallesim）"></a>并行（Parallesim）</h3><p>是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>『并发』指的是程序的结构，『并行』指的是程序运行时的状态</li>
<li>『并行』一定是并发的，『并行』是『并发』设计的一种</li>
<li>单线程永远无法达到『并行』状态</li>
</ul>
<p>正确的并发设计的标准是：</p>
<blockquote>
<p>使多个操作可以在重叠的时间段内进行。<br>two tasks can start, run, and complete in overlapping time periods</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a href="http://www.vaikan.com/docs/Concurrency-is-not-Parallelism" target="_blank" rel="external">http://www.vaikan.com/docs/Concurrency-is-not-Parallelism</a></li>
<li><a href="https://talks.golang.org/2012/waza.slide" target="_blank" rel="external">https://talks.golang.org/2012/waza.slide</a></li>
</ul>
<h2 id="迭代器-amp-生成器"><a href="#迭代器-amp-生成器" class="headerlink" title="迭代器 &amp; 生成器"></a>迭代器 &amp; 生成器</h2><p>在了解 PHP 协程前，还有 <strong>迭代器</strong> 和 <strong>生成器</strong> 这两个概念需要先认识一下。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>PHP5 开始内置了 <code>Iterator</code> 即迭代器接口，所以如果你定义了一个类，并实现了<code>Iterator</code> 接口，那么你的这个类对象就是 <code>ZEND_ITER_OBJECT</code> 即可迭代的，否则就是 <code>ZEND_ITER_PLAIN_OBJECT</code>。</p>
<p>对于 <code>ZEND_ITER_PLAIN_OBJECT</code> 的类，<code>foreach</code> 会获取该对象的默认属性数组，然后对该数组进行迭代。</p>
<p>而对于 <code>ZEND_ITER_OBJECT</code> 的类对象，则会通过调用对象实现的 <code>Iterator</code> 接口相关函数来进行迭代。</p>
<p>任何实现了 <code>Iterator</code> 接口的类都是<strong>可迭代的</strong>，即都可以用 <code>foreach</code> 语句来遍历。</p>
<h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> <span class="keyword">extends</span> <span class="title">Traversable</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 获取当前内部标量指向的元素的数据</span></div><div class="line">    <span class="keyword">public</span> mixed current()</div><div class="line"></div><div class="line">	<span class="comment">// 获取当前标量</span></div><div class="line">    <span class="keyword">public</span> scalar key()</div><div class="line"></div><div class="line">	<span class="comment">// 移动到下一个标量</span></div><div class="line">    <span class="keyword">public</span> void next()</div><div class="line"></div><div class="line">	<span class="comment">// 重置标量</span></div><div class="line">    <span class="keyword">public</span> void rewind()</div><div class="line"></div><div class="line">	<span class="comment">// 检查当前标量是否有效</span></div><div class="line">    <span class="keyword">public</span> boolean valid()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常规实现-range-函数"><a href="#常规实现-range-函数" class="headerlink" title="常规实现 range 函数"></a>常规实现 range 函数</h4><p>PHP 自带的 range 函数原型：</p>
<blockquote>
<p>range — 根据范围创建数组，包含指定的元素</p>
<p>array range (mixed $start , mixed $end [, number $step = 1 ])</p>
<p>建立一个包含指定范围单元的数组。</p>
</blockquote>
<p>在不使用迭代器的情况要实现一个和 PHP 自带的 <code>range</code> 函数类似的功能，可能会这么写：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span> <span class="params">($start, $end, $step = <span class="number">1</span>)</span></span></div><div class="line">&#123;</div><div class="line">    $ret = [];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> ($i = $start; $i &lt;= $end; $i += $step) &#123;</div><div class="line">        $ret[] = $i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> $ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要将生成的所有元素放在内存数组中，如果需要生成一个非常大的集合，则会占用巨大的内存。</p>
<h4 id="迭代器实现-xrange-函数"><a href="#迭代器实现-xrange-函数" class="headerlink" title="迭代器实现 xrange 函数"></a>迭代器实现 xrange 函数</h4><p>来看看迭代实现的 <code>range</code>，我们叫做 <code>xrange</code>，他实现了 <code>Iterator</code> 接口必须的 5 个方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xrange</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $start;</div><div class="line">    <span class="keyword">protected</span> $limit;</div><div class="line">    <span class="keyword">protected</span> $step;</div><div class="line">    <span class="keyword">protected</span> $current;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($start, $limit, $step = <span class="number">1</span>)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;start = $start;</div><div class="line">        <span class="keyword">$this</span>-&gt;limit = $limit;</div><div class="line">        <span class="keyword">$this</span>-&gt;step  = $step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;current = <span class="keyword">$this</span>-&gt;start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;current += <span class="keyword">$this</span>-&gt;step;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;current &lt;= <span class="keyword">$this</span>-&gt;limit;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用时代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">foreach</span> (<span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">9</span>) <span class="keyword">as</span> $key =&gt; $val) &#123;</div><div class="line">    <span class="keyword">echo</span> $key, <span class="string">' '</span>, $val, <span class="string">"\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">0 </span><span class="number">0</span></div><div class="line"><span class="symbol">1 </span><span class="number">1</span></div><div class="line"><span class="symbol">2 </span><span class="number">2</span></div><div class="line"><span class="symbol">3 </span><span class="number">3</span></div><div class="line"><span class="symbol">4 </span><span class="number">4</span></div><div class="line"><span class="symbol">5 </span><span class="number">5</span></div><div class="line"><span class="symbol">6 </span><span class="number">6</span></div><div class="line"><span class="symbol">7 </span><span class="number">7</span></div><div class="line"><span class="symbol">8 </span><span class="number">8</span></div><div class="line"><span class="symbol">9 </span><span class="number">9</span></div></pre></td></tr></table></figure>
<p>看上去功能和 <code>range()</code> 函数所做的一致，不同点在于迭代的是一个 <code>对象(Object)</code> 而不是数组：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var_dump(<span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">9</span>));</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">object(Xrange)<span class="comment">#1 (4) &#123;</span></div><div class="line">  [<span class="string">"start"</span>:<span class="keyword">protected</span>]=&gt;</div><div class="line">  <span class="keyword">int</span>(<span class="number">0</span>)</div><div class="line">  [<span class="string">"limit"</span>:<span class="keyword">protected</span>]=&gt;</div><div class="line">  <span class="keyword">int</span>(<span class="number">9</span>)</div><div class="line">  [<span class="string">"step"</span>:<span class="keyword">protected</span>]=&gt;</div><div class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</div><div class="line">  [<span class="string">"current"</span>:<span class="keyword">protected</span>]=&gt;</div><div class="line">  <span class="keyword">NULL</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，内存的占用情况也完全不同：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// range</span></div><div class="line">$startMemory = memory_get_usage();</div><div class="line">$arr = range(<span class="number">0</span>, <span class="number">500000</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'range(): '</span>, memory_get_usage() - $startMemory, <span class="string">" bytes\n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">unset</span>($arr);</div><div class="line"></div><div class="line"><span class="comment">// xrange</span></div><div class="line">$startMemory = memory_get_usage();</div><div class="line">$arr = <span class="keyword">new</span> Xrange(<span class="number">0</span>, <span class="number">500000</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'xrange(): '</span>, memory_get_usage() - $startMemory, <span class="string">" bytes\n"</span>;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">xrange</span><span class="params">()</span></span>: <span class="number">624</span> bytes</div><div class="line"><span class="function"><span class="title">range</span><span class="params">()</span></span>: <span class="number">72194784</span> bytes</div></pre></td></tr></table></figure>
<p><code>range()</code> 函数在执行后占用了 50W 个元素内存空间，而 <code>xrange</code> 对象在整个迭代过程中只占用一个对象的内存。</p>
<h4 id="Yii2-Query"><a href="#Yii2-Query" class="headerlink" title="Yii2 Query"></a>Yii2 Query</h4><p>在喜闻乐见的各种 PHP 框架里有不少生成器的实例，比如 Yii2 中用来构建 SQL 语句的 <code>\yii\db\Query</code> 类：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$query = (<span class="keyword">new</span> \yii\db\Query)-&gt;from(<span class="string">'user'</span>);</div><div class="line"><span class="comment">// yii\db\BatchQueryResult</span></div><div class="line"><span class="keyword">foreach</span> ($query-&gt;batch() <span class="keyword">as</span> $users) &#123;</div><div class="line">    <span class="comment">// 每次循环得到多条 user 记录</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看一下 <code>batch()</code> 做了什么：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Starts a batch query.</div><div class="line">*</div><div class="line">* A batch query supports fetching data in batches, which can keep the memory usage under a limit.</div><div class="line">* This method will return a [[BatchQueryResult]] object which implements the [[\Iterator]] interface</div><div class="line">* and can be traversed to retrieve the data in batches.</div><div class="line">*</div><div class="line">* For example,</div><div class="line">*</div><div class="line">*</div><div class="line">* $query = (new Query)-&gt;from('user');</div><div class="line">* foreach ($query-&gt;batch() as $rows) &#123;</div><div class="line">*     // $rows is an array of 10 or fewer rows from user table</div><div class="line">* &#125;</div><div class="line">*</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> integer $batchSize the number of records to be fetched in each batch.</div><div class="line">* <span class="doctag">@param</span> Connection $db the database connection. If not set, the "db" application component will be used.</div><div class="line">* <span class="doctag">@return</span> BatchQueryResult the batch query result. It implements the [[\Iterator]] interface</div><div class="line">* and can be traversed to retrieve the data in batches.</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">batch</span><span class="params">($batchSize = <span class="number">100</span>, $db = null)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> Yii::createObject([</div><div class="line">       <span class="string">'class'</span> =&gt; BatchQueryResult::className(),</div><div class="line">       <span class="string">'query'</span> =&gt; <span class="keyword">$this</span>,</div><div class="line">       <span class="string">'batchSize'</span> =&gt; $batchSize,</div><div class="line">       <span class="string">'db'</span> =&gt; $db,</div><div class="line">       <span class="string">'each'</span> =&gt; <span class="keyword">false</span>,</div><div class="line">   ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上返回了一个 <code>BatchQueryResult</code> 类，类的源码实现了 <code>Iterator</code> 接口 5  个关键方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchQueryResult</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> \<span class="title">Iterator</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> $db;</div><div class="line">    <span class="keyword">public</span> $query;</div><div class="line">    <span class="keyword">public</span> $batchSize = <span class="number">100</span>;</div><div class="line">    <span class="keyword">public</span> $each = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> $_dataReader;</div><div class="line">    <span class="keyword">private</span> $_batch;</div><div class="line">    <span class="keyword">private</span> $_value;</div><div class="line">    <span class="keyword">private</span> $_key;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Destructor.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// make sure cursor is closed</span></div><div class="line">        <span class="keyword">$this</span>-&gt;reset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Resets the batch query.</div><div class="line">     * This method will clean up the existing batch query so that a new batch query can be performed.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_dataReader !== <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_dataReader-&gt;close();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">$this</span>-&gt;_dataReader = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_batch = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_value = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">$this</span>-&gt;_key = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Resets the iterator to the initial state.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;reset();</div><div class="line">        <span class="keyword">$this</span>-&gt;next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Moves the internal pointer to the next dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_batch === <span class="keyword">null</span> || !<span class="keyword">$this</span>-&gt;each || <span class="keyword">$this</span>-&gt;each &amp;&amp; next(<span class="keyword">$this</span>-&gt;_batch) === <span class="keyword">false</span>) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_batch = <span class="keyword">$this</span>-&gt;fetchData();</div><div class="line">            reset(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;each) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_value = current(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;query-&gt;indexBy !== <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key = key(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">            &#125; <span class="keyword">elseif</span> (key(<span class="keyword">$this</span>-&gt;_batch) !== <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key++;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;_key = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_value = <span class="keyword">$this</span>-&gt;_batch;</div><div class="line">            <span class="keyword">$this</span>-&gt;_key = <span class="keyword">$this</span>-&gt;_key === <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">$this</span>-&gt;_key + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Fetches the next batch of data.</div><div class="line">     * <span class="doctag">@return</span> array the data fetched</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the index of the current dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> integer the index of the current row.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">key</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the current dataset.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> mixed the current dataset.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns whether there is a valid dataset at the current position.</div><div class="line">     * This method is required by the interface [[\Iterator]].</div><div class="line">     * <span class="doctag">@return</span> boolean whether there is a valid dataset at the current position.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;_batch);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以迭代器的方式实现了类似分页取的效果，同时避免了一次性取出所有数据占用太多的内存空间。</p>
<h4 id="迭代器使用场景"><a href="#迭代器使用场景" class="headerlink" title="迭代器使用场景"></a>迭代器使用场景</h4><ul>
<li>使用返回迭代器的包或库时（如 PHP5 中的 SPL 迭代器）</li>
<li>无法在一次调用获取所需的所有元素时</li>
<li>要处理数量巨大的元素时（数据库中要处理的结果集内容超过内存）</li>
<li>…</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><div class="tip">需要 PHP 5 &gt;= 5.5.0 或 PHP 7</div>

<p>虽然迭代器仅需继承接口即可实现，但毕竟需要定义一整个类然后实现接口的所有方法，实在是不怎么方便。</p>
<blockquote><p>生成器则提供了一种更简单的方式来实现简单的对象迭代，相比定义类来实现 <code>Iterator</code> 接口的方式，性能开销和复杂度大大降低。</p>
<footer><strong>PHP Manual</strong></footer></blockquote>
<p>生成器允许在 <code>foreach</code> 代码块中迭代一组数据而不需要创建任何数组。一个生成器函数，就像一个普通的有返回值的自定义函数类似，但普通函数只返回一次, 而生成器可以根据需要通过 <code>yield</code> 关键字返回多次，以便连续生成需要迭代返回的值。</p>
<p>一个最简单的例子就是使用生成器来重新实现 <code>xrange()</code> 函数。效果和上面我们用迭代器实现的差不多，但实现起来要简单的多。</p>
<h4 id="生成器实现-xrange-函数"><a href="#生成器实现-xrange-函数" class="headerlink" title="生成器实现 xrange 函数"></a>生成器实现 <code>xrange</code> 函数</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">xrange</span><span class="params">($start, $limit, $step = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $limit; $i += $step) &#123; </div><div class="line">        <span class="keyword">yield</span> $i + <span class="number">1</span> =&gt; $i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">foreach</span> (xrange(<span class="number">0</span>, <span class="number">9</span>) <span class="keyword">as</span> $key =&gt; $val) &#123;</div><div class="line">    printf(<span class="string">"%d %d \n"</span>, $key, $val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="comment">// 1 0</span></div><div class="line"><span class="comment">// 2 1</span></div><div class="line"><span class="comment">// 3 2</span></div><div class="line"><span class="comment">// 4 3</span></div><div class="line"><span class="comment">// 5 4</span></div><div class="line"><span class="comment">// 6 5</span></div><div class="line"><span class="comment">// 7 6</span></div><div class="line"><span class="comment">// 8 7</span></div><div class="line"><span class="comment">// 9 8</span></div></pre></td></tr></table></figure>
<p>实际上生成器生成的正是一个迭代器对象实例，该迭代器对象继承了 <code>Iterator</code> 接口，同时也包含了生成器对象自有的接口，具体可以参考 <a href="http://php.net/manual/zh/class.generator.php" target="_blank" rel="external">Generator</a> 类的定义以及<a href="http://php.net/manual/zh/language.generators.syntax.php" target="_blank" rel="external">语法参考</a>。</p>
<p>同时需要注意的是：</p>
<div class="tip"><br>一个生成器不可以返回值，这样做会产生一个编译错误。然而 return 空是一个有效的语法并且它将会终止生成器继续执行。<br></div>

<h4 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h4><p>需要注意的是 <code>yield</code> 关键字，这是生成器的关键。通过上面的例子可以看出，<code>yield</code> 会将当前产生的值传递给 <code>foreach</code>，换句话说，<code>foreach</code> 每一次迭代过程都会从 <code>yield</code> 处取一个值，直到整个遍历过程不再能执行到 <code>yield</code> 时遍历结束，此时生成器函数简单的退出，而调用生成器的上层代码还可以继续执行，就像一个数组已经被遍历完了。</p>
<p><code>yield</code> 最简单的调用形式看起来像一个 <code>return</code> 申明，不同的是 <code>yield</code> 暂停当前过程的执行并返回值，而 <code>return</code> 是中断当前过程并返回值。暂停当前过程，意味着将处理权转交由上一级继续进行，直到上一级再次调用被暂停的过程，该过程又会从上一次暂停的位置继续执行。这像是什么呢？如果之前已经在<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">鸟哥的文章</a>中粗略看过，应该知道这很像操作系统的进程调度，多个进程在一个 CPU 核心上执行，在系统调度下每一个进程执行一段指令就被暂停，切换到下一个进程，这样外部用户看起来就像是同时在执行多个任务。</p>
<p>但仅仅如此还不够，<code>yield</code> 除了可以返回值以外，还能接收值，也就是可以在两个层级间实现<strong>双向通信</strong>。</p>
<p>来看看如何传递一个值给 <code>yield</code>：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        printf(<span class="string">"receive: %s\n"</span>, <span class="keyword">yield</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line"></div><div class="line">$printer-&gt;send(<span class="string">'hello'</span>);</div><div class="line">$printer-&gt;send(<span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line">receive: hello</div><div class="line">receive: world</div></pre></td></tr></table></figure>
<p>根据 <a href="http://php.net/manual/zh/generator.send.php" target="_blank" rel="external">PHP 官方文档</a>的描述可以知道 <code>Generator</code> 对象除了实现 <code>Iterator</code> 接口中的必要方法以外，还有一个 <code>send</code> 方法，这个方法就是向 <code>yield</code> 语句处传递一个值，同时从 <code>yield</code> 语句处继续执行，直至再次遇到 <code>yield</code> 后控制权回到外部。</p>
<p>既然 <code>yield</code> 可以在其位置中断并返回或者接收一个值，那能不能同时进行<strong>接收</strong>和<strong>返回</strong>呢？当然，这也是实现协程的根本。对上述代码做出修改：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    $i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        printf(<span class="string">"receive: %s\n"</span>, (<span class="keyword">yield</span> ++$i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$printer = printer();</div><div class="line"></div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line">$printer-&gt;send(<span class="string">'hello'</span>);</div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line">$printer-&gt;send(<span class="string">'world'</span>);</div><div class="line">printf(<span class="string">"%d\n"</span>, $printer-&gt;current());</div><div class="line"></div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="number">1</span></div><div class="line">receive: hello</div><div class="line"><span class="number">2</span></div><div class="line">receive: world</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>这是另一个例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">    $ret = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</div><div class="line">    var_dump($ret);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">$gen = gen();</div><div class="line">var_dump($gen-&gt;current());    <span class="comment">// string(6) "yield1"</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (第一个 var_dump)</span></div><div class="line">                              <span class="comment">// string(6) "yield2" (继续执行到第二个 yield，吐出了返回值)</span></div><div class="line">var_dump($gen-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (第二个 var_dump)</span></div><div class="line">                              <span class="comment">// NULL (var_dump 之后没有其他语句，所以这次 -&gt;send() 的返回值为 null)</span></div></pre></td></tr></table></figure>
<p><code>current</code> 方法是迭代器 <code>Iterator</code> 接口必要的方法，<code>foreach</code> 语句每一次迭代都会通过其获取当前值，而后调用迭代器的 <code>next</code> 方法。在上述例子里则是手动调用了 <code>current</code> 方法获取值。</p>
<p>上述例子已经足以表示 <strong>yield</strong> 能够作为实现双向通信的工具，也就是具备了后续实现协程的基本条件。</p>
<p>上面的例子如果第一次接触并稍加思考，不免会疑惑为什么一个 <code>yield</code> 既是语句又是表达式，而且这两种情况还同时存在：</p>
<ul>
<li>对于所有在<strong>生成器</strong>函数中出现的 <code>yield</code>，首先它都是语句，而跟在 <code>yield</code> 后面的任何表达式的值将作为调用生成器函数的返回值，如果 <code>yield</code> 后面没有任何表达式（变量、常量都是表达式），那么它会返回 <code>NULL</code>，这一点和 <code>return</code> 语句一致。</li>
<li><code>yield</code> 也是表达式，它的值就是 <code>send</code> 函数传过来的值（相当于一个特殊变量，只不过赋值是通过 <code>send</code> 函数进行的）。只要调用send方法，并且生成器对象的迭代并未终结，那么当前位置的 <code>yield</code> 就会得到 <code>send</code> 方法传递过来的值，这和生成器函数有没有把这个值赋值给某个变量没有任何关系。</li>
</ul>
<p>这个地方可能需要仔细品味上面两个 <code>send()</code> 方法的例子才能理解。但可以简单的记住：</p>
<div class="tip"><br>任何时候 yield 关键词即是语句：可以为生成器函数返回值；<br>也是表达式：可以接收生成器对象发过来的值。<br></div>

<p>除了 <code>send()</code> 方法，还有一种控制生成器执行的方法是 <code>next()</code> 函数：</p>
<ul>
<li><code>Next()</code>，恢复生成器函数的执行直到下一个 <code>yield</code></li>
<li><code>Send()</code>，向生成器传入一个值，恢复执行直到下一个 <code>yield</code></li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>对于单核处理器，多进程实现多任务的原理是让操作系统给一个任务每次分配一定的 CPU 时间片，然后中断、让下一个任务执行一定的时间片接着再中断并继续执行下一个，如此反复。由于切换执行任务的速度非常快，给外部用户的感受就是多个任务的执行是同时进行的。</p>
<p>多进程的调度是由操作系统来实现的，进程自身不能控制自己何时被调度，也就是说：</p>
<blockquote>
<p>进程的调度是由外层调度器抢占式实现的</p>
</blockquote>
<p>而<strong>协程</strong>要求当前正在运行的任务自动把控制权回传给调度器，这样就可以继续运行其他任务。这与『抢占式』的多任务正好相反, 抢占多任务的调度器可以强制中断正在运行的任务, 不管它自己有没有意愿。『协作式多任务』在 Windows 的早期版本 (windows95) 和 Mac OS 中有使用, 不过它们后来都切换到『抢占式多任务』了。理由相当明确：如果仅依靠程序自动交出控制的话，那么一些恶意程序将会很容易占用全部 CPU 时间而不与其他任务共享。</p>
<blockquote>
<p>协程的调度是由协程自身主动让出控制权到外层调度器实现的</p>
</blockquote>
<p>回到刚才<strong>生成器</strong>实现 <code>xrange</code> 函数的例子，整个执行过程的交替可以用下图来表示：</p>
<img src="/2017/02/10/PHP-协程原理/14912153136517.jpg" alt="14912153136517.jpg" title="">
<p>协程可以理解为<strong>纯用户态</strong>的线程，通过协作而不是抢占来进行任务切换。相对于进程或者线程，协程所有的操作都可以在用户态而非操作系统内核态完成，创建和切换的消耗非常低。</p>
<p>简单的说 <strong>Coroutine（协程）</strong> 就是提供一种方法来中断当前任务的执行，保存当前的局部变量，下次再过来又可以恢复当前局部变量继续执行。</p>
<p>我们可以把大任务拆分成多个小任务轮流执行，如果有某个小任务在等待系统 IO，就跳过它，执行下一个小任务，这样往复调度，实现了 IO 操作和 CPU 计算的并行执行，总体上就提升了任务的执行效率，这也便是协程的意义。</p>
<h3 id="PHP-协程和-yield"><a href="#PHP-协程和-yield" class="headerlink" title="PHP 协程和 yield"></a>PHP 协程和 yield</h3><p>PHP 从 5.5 开始支持生成器及 <code>yield</code> 关键字，而 PHP 协程则由 <code>yield</code> 来实现。</p>
<p>要理解协程，首先要理解：代码是代码，函数是函数。函数包裹的代码赋予了这段代码附加的意义：不管是否显式的指明返回值，当函数内的代码块执行完后都会返回到调用层。而当调用层调用某个函数的时候，必须等这个函数返回，当前函数才能继续执行，这就构成了后进先出，也就是 <code>Stack</code>。</p>
<p>而协程包裹的代码，不是函数，不完全遵守函数的附加意义，协程执行到某个点，协会协程会 <code>yield</code> 返回一个值然后挂起，而不是 <code>return</code> 一个值然后结束，当再次调用协程的时候，会在上次 <code>yield</code> 的点继续执行。</p>
<p>所以协程违背了通常操作系统和 x86 的 CPU 认定的代码执行方式，也就是 <code>Stack</code> 的这种执行方式，需要运行环境（比如 php，python 的 yield 和 golang 的 goroutine）自己调度，来实现任务的中断和恢复，具体到 PHP，就是靠 <code>yield</code> 来实现。</p>
<p><strong>堆栈式调用</strong> 和 <strong>协程调用</strong>的对比：</p>
<img src="/2017/02/10/PHP-协程原理/14912192095503.jpg" alt="14912192095503.jpg" title="">
<p>结合之前的例子，可以总结一下 <code>yield</code> 能做的就是：</p>
<ul>
<li>实现不同任务间的主动让位、让行，把控制权交回给任务调度器。</li>
<li>通过 <code>send()</code> 实现不同任务间的双向通信，也就可以实现任务和调度器之间的通信。</li>
</ul>
<p><code>yield</code> 就是 PHP 实现协程的方式。</p>
<h3 id="协程多任务调度"><a href="#协程多任务调度" class="headerlink" title="协程多任务调度"></a>协程多任务调度</h3><p>下面是雄文 <a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">Cooperative multitasking using coroutines (in PHP!)</a> 里一个简单但完整的例子，来展示如何具体的在 PHP 里实现协程任务的调度。</p>
<p>首先是一个任务类：</p>
<p><strong>Task</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 任务 ID</span></div><div class="line">    <span class="keyword">protected</span> $taskId;</div><div class="line">    <span class="comment">// 协程对象</span></div><div class="line">    <span class="keyword">protected</span> $coroutine;</div><div class="line">    <span class="comment">// send() 值</span></div><div class="line">    <span class="keyword">protected</span> $sendVal = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 是否首次 yield</span></div><div class="line">    <span class="keyword">protected</span> $beforeFirstYield = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($taskId, Generator $coroutine)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskId = $taskId;</div><div class="line">        <span class="keyword">$this</span>-&gt;coroutine = $coroutine;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;taskId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSendValue</span><span class="params">($sendVal)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;sendVal = $sendVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 如之前提到的在send之前, 当迭代器被创建后第一次 yield 之前，一个 renwind() 方法会被隐式调用</span></div><div class="line">        <span class="comment">// 所以实际上发生的应该类似:</span></div><div class="line">        <span class="comment">// $this-&gt;coroutine-&gt;rewind();</span></div><div class="line">        <span class="comment">// $this-&gt;coroutine-&gt;send();</span></div><div class="line">         </div><div class="line">        <span class="comment">// 这样 renwind 的执行将会导致第一个 yield 被执行, 并且忽略了他的返回值.</span></div><div class="line">        <span class="comment">// 真正当我们调用 yield 的时候, 我们得到的是第二个yield的值，导致第一个yield的值被忽略。</span></div><div class="line">        <span class="comment">// 所以这个加上一个是否第一次 yield 的判断来避免这个问题</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;beforeFirstYield) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;beforeFirstYield = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;coroutine-&gt;current();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            $retval = <span class="keyword">$this</span>-&gt;coroutine-&gt;send(<span class="keyword">$this</span>-&gt;sendVal);</div><div class="line">            <span class="keyword">$this</span>-&gt;sendVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> $retval;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;coroutine-&gt;valid();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是调度器，比 <code>foreach</code> 是要复杂一点，但好歹也能算个正儿八经的 <code>Scheduler</code> :)</p>
<p><strong>Scheduler</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">protected</span> $taskMap = []; <span class="comment">// taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $taskQueue;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;taskQueue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// （使用下一个空闲的任务id）创建一个新任务,然后把这个任务放入任务map数组里. 接着它通过把任务放入任务队列里来实现对任务的调度. 接着run()方法扫描任务队列, 运行任务.如果一个任务结束了, 那么它将从队列里删除, 否则它将在队列的末尾再次被调度。</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</div><div class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</div><div class="line">        <span class="keyword">$this</span>-&gt;taskMap[$tid] = $task;</div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $tid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">    	<span class="comment">// 任务入队</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty()) &#123;</div><div class="line">        	<span class="comment">// 任务出队</span></div><div class="line">            $task = <span class="keyword">$this</span>-&gt;queue-&gt;dequeue();</div><div class="line">            $task-&gt;run();</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;taskMap[$task-&gt;getTaskId()]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>队列可以使每个任务获得同等的 CPU 使用时间，</p>
<p><strong>Demo</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">10</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 1 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= <span class="number">5</span>; ++$i) &#123;</div><div class="line">        <span class="keyword">echo</span> <span class="string">"This is task 2 iteration $i.\n"</span>;</div><div class="line">        <span class="keyword">yield</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">$scheduler = <span class="keyword">new</span> Scheduler;</div><div class="line"> </div><div class="line">$scheduler-&gt;newTask(task1());</div><div class="line">$scheduler-&gt;newTask(task2());</div><div class="line"> </div><div class="line">$scheduler-&gt;run();</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">1</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">2</span> iteration <span class="number">1</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">2</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">2</span> iteration <span class="number">2</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">3</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">2</span> iteration <span class="number">3</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">4</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">2</span> iteration <span class="number">4</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">5</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">2</span> iteration <span class="number">5</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">6</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">7</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">8</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">9</span>.</div><div class="line">This <span class="keyword">is</span> <span class="keyword">task</span> <span class="number">1</span> iteration <span class="number">10</span>.</div></pre></td></tr></table></figure>
<p>结果正是我们期待的，最初的 5 次迭代，两个任务是交替进行的，而在第二个任务结束后，只有第一个任务继续执行到结束。</p>
<h3 id="协程非阻塞-IO"><a href="#协程非阻塞-IO" class="headerlink" title="协程非阻塞 IO"></a>协程非阻塞 IO</h3><p>若想真正的发挥出协程的作用，那一定是在一些涉及到阻塞 IO 的场景，我们都知道 Web 服务器最耗时的部分通常都是 socket 读取数据等操作上，如果进程对每个请求都挂起的等待 IO 操作，那处理效率就太低了，接下来我们看个支持非阻塞 IO 的 Scheduler：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $maxTaskId = <span class="number">0</span>;</div><div class="line">    <span class="keyword">protected</span> $tasks = []; <span class="comment">// taskId =&gt; task</span></div><div class="line">    <span class="keyword">protected</span> $queue;</div><div class="line"></div><div class="line">    <span class="comment">// resourceID =&gt; [socket, tasks]</span></div><div class="line">    <span class="keyword">protected</span> $waitingForRead = [];</div><div class="line">    <span class="keyword">protected</span> $waitingForWrite = [];</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// SPL 队列</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue = <span class="keyword">new</span> SplQueue();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span><span class="params">(Generator $coroutine)</span> </span>&#123;</div><div class="line">        $tid = ++<span class="keyword">$this</span>-&gt;maxTaskId;</div><div class="line">        $task = <span class="keyword">new</span> Task($tid, $coroutine);</div><div class="line">        <span class="keyword">$this</span>-&gt;tasks[$tid] = $task;</div><div class="line">        <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">        <span class="keyword">return</span> $tid;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">schedule</span><span class="params">(Task $task)</span> </span>&#123;</div><div class="line">    	<span class="comment">// 任务入队</span></div><div class="line">        <span class="keyword">$this</span>-&gt;queue-&gt;enqueue($task);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty()) &#123;</div><div class="line">        	<span class="comment">// 任务出队</span></div><div class="line">            $task = <span class="keyword">$this</span>-&gt;queue-&gt;dequeue();</div><div class="line">            $task-&gt;run();</div><div class="line"> </div><div class="line">            <span class="keyword">if</span> ($task-&gt;isFinished()) &#123;</div><div class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;tasks[$task-&gt;getTaskId()]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForRead</span><span class="params">($socket, Task $task)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket])) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket][<span class="number">1</span>][] = $task;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket] = [$socket, [$task]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">waitForWrite</span><span class="params">($socket, Task $task)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket])) &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket][<span class="number">1</span>][] = $task;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket] = [$socket, [$task]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> $timeout 0 represent</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPoll</span><span class="params">($timeout)</span></span></div><div class="line">    &#123;</div><div class="line">        $rSocks = [];</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForRead <span class="keyword">as</span> <span class="keyword">list</span>($socket)) &#123;</div><div class="line">            $rSocks[] = $socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $wSocks = [];</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;waitingForWrite <span class="keyword">as</span> <span class="keyword">list</span>($socket)) &#123;</div><div class="line">            $wSocks[] = $socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $eSocks = [];</div><div class="line">        <span class="comment">// $timeout 为 0 时, stream_select 为立即返回，为 null 时则会阻塞的等，见 http://php.net/manual/zh/function.stream-select.php</span></div><div class="line">        <span class="keyword">if</span> (!@stream_select($rSocks, $wSocks, $eSocks, $timeout)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> ($rSocks <span class="keyword">as</span> $socket) &#123;</div><div class="line">            <span class="keyword">list</span>(, $tasks) = <span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket];</div><div class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;waitingForRead[(int)$socket]);</div><div class="line"></div><div class="line">            <span class="keyword">foreach</span> ($tasks <span class="keyword">as</span> $task) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> ($wSocks <span class="keyword">as</span> $socket) &#123;</div><div class="line">            <span class="keyword">list</span>(, $tasks) = <span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket];</div><div class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;waitingForWrite[(int)$socket]);</div><div class="line"></div><div class="line">            <span class="keyword">foreach</span> ($tasks <span class="keyword">as</span> $task) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;schedule($task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 检查队列是否为空，若为空则挂起的执行 stream_select，否则检查完 IO 状态立即返回，详见 ioPoll()</div><div class="line">     * 作为任务加入队列后，由于 while true，会被一直重复的加入任务队列，实现每次任务前检查 IO 状态</div><div class="line">     * <span class="doctag">@return</span> Generator object for newTask</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">ioPollTask</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;ioPoll(<span class="keyword">null</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">$this</span>-&gt;ioPoll(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">yield</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * $scheduler = new Scheduler;</div><div class="line">     * $scheduler-&gt;newTask(Web Server Generator);</div><div class="line">     * $scheduler-&gt;withIoPoll()-&gt;run();</div><div class="line">     *</div><div class="line">     * 新建 Web Server 任务后先执行 withIoPoll() 将 ioPollTask() 作为任务入队</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> $this</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">withIoPoll</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;newTask(<span class="keyword">$this</span>-&gt;ioPollTask());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个版本的 Scheduler 里加入一个永不退出的任务，并且通过 <code>stream_select</code> 支持的特性来实现快速的来回检查各个任务的 IO 状态，只有 IO 完成的任务才会继续执行，而 IO 还未完成的任务则会跳过，完整的代码和例子可以<a href="https://github.com/Jamlee/coroutine" target="_blank" rel="external">戳这里</a>。</p>
<p>也就是说任务交替执行的过程中，一旦遇到需要 IO 的部分，调度器就会把 CPU 时间分配给不需要 IO 的任务，等到当前任务遇到 IO 或者之前的任务 IO 结束才再次调度 CPU 时间，以此实现 CPU 和 IO 并行来提升执行效率，类似下图：</p>
<img src="/2017/02/10/PHP-协程原理/14913877605869.jpg" alt="14913877605869.jpg" title="">
<h3 id="单任务改造"><a href="#单任务改造" class="headerlink" title="单任务改造"></a>单任务改造</h3><p>如果想将一个单进程任务改造成并发执行，我们可以选择改造成多进程或者协程：</p>
<ul>
<li>多进程，不改变任务执行的整体过程，在一个时间段内同时执行多个相同的代码段，调度权在 CPU，如果一个任务能独占一个 CPU 则可以实现并行。</li>
<li>协程，把原有任务拆分成多个小任务，原有任务的执行流程被改变，调度权在进程自己，如果有 IO 并且可以实现异步，则可以实现并行。</li>
</ul>
<p><strong>多进程改造</strong></p>
<img src="/2017/02/10/PHP-协程原理/14914233052018.jpg" alt="14914233052018.jpg" title="">
<p><strong>协程改造</strong></p>
<img src="/2017/02/10/PHP-协程原理/14914233296912.jpg" alt="14914233296912.jpg" title="">
<h2 id="协程（Coroutines）和-Go-协程（Goroutines）"><a href="#协程（Coroutines）和-Go-协程（Goroutines）" class="headerlink" title="协程（Coroutines）和 Go 协程（Goroutines）"></a>协程（Coroutines）和 Go 协程（Goroutines）</h2><p>PHP 的协程或者其他语言中，比如 Python、Lua 等都有协程的概念，和 Go 协程有些相似，不过有两点不同：</p>
<ul>
<li>Go 协程意味着并行（或者可以以并行的方式部署，可以用 <code>runtime.GOMAXPROCS()</code> 指定可同时使用的 CPU 个数），协程一般来说只是并发。</li>
<li>Go 协程通过通道 <code>channel</code> 来通信；协程通过 <code>yield</code> 让出和恢复操作来通信。</li>
</ul>
<p>Go 协程比普通协程更强大，也很容易从协程的逻辑复用到 Go 协程，而且在 Go 的开发中也使用的极为普遍，有兴趣的话可以了解一下作为对比。</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>个人感觉 PHP 的协程在实际使用中想要徒手实现和应用并不方便而且场景有限，但了解其概念及实现原理对更好的理解并发不无裨益。</p>
<p>如果想更多的了解协程的实际应用场景不妨试试已经大名鼎鼎的 <a href="https://wiki.swoole.com/wiki/page/p-coroutine.html" target="_blank" rel="external">Swoole</a>，其对多种协议的 client 做了底层的协程封装，几乎可以做到以同步编程的写法实现协程异步 IO 的效果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">Cooperative multitasking using coroutines (in PHP!)</a></li>
<li><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">在PHP中使用协程实现多任务调度</a></li>
<li><a href="http://rango.swoole.com/archives/508" target="_blank" rel="external">PHP 并发 IO 编程之路</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/07/如何避开-Go-中的各种陷阱/" class="next">NEXT</a></div><div data-thread-key="2017/02/10/PHP-协程原理/" data-title="PHP 协程原理" data-url="http://yoursite.com/2017/02/10/PHP-协程原理/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"newt0n"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Newton</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>